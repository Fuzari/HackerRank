**Q:** Чему равны значения `tutorial1.difficulty` и `tutorial2.difficulty?` 

```swift
struct Tutorial {
  var difficulty: Int = 1
}

var tutorial1 = Tutorial()
var tutorial2 = tutorial1
tutorial2.difficulty = 2
```


Была бы какая-то разница, если бы Tutorial был классом? Почему?

**A:** `tutorial1.difficulty равен 1`, а `tutorial2.difficulty равен 2`.

В Swift структуры — типы-значения (value type). Они копируются, а не ссылаются. 
Следующая строка копирует tutorial1 и присваивает её tutorial2:
`var tutorial2 = tutorial1`
Изменения в tutorial2 не отражаются на tutorial1.

Если бы Tutorial был бы классом, tutorial1.difficulty и tutorial2.difficulty равнялись бы 2. 
Классы в Swift — ссылочные типы (reference type). Когда вы меняете свойство tutorial1, 
вы увидите такое же изменение у tutorial2 — и наоборот.

------



**Q:** Вы объявили view1 при помощи var, а view2 — при помощи let. В чём разница и скомпилируется ли последняя строка?

```swift
import UIKit

var view1 = UIView()
view1.alpha = 0.5

let view2 = UIView()
view2.alpha = 0.5 // Эта строка скомпилируется?
```

**A:** Да, последняя строка скомпилируется. 
view1 — это переменная, и вы можете назначить её значение новым экземпляром IView. Используя let, вы можете присвоить значение лишь однажды, так что следующий код не скомпилируется:

```swift
view2 = view1 // Ошибка: view2 is immutable
```

Однако, UIView — это класс со ссылочной семантикой, 
так что вы можете изменять свойства view2 — что означает, что код скомпилируется.

------



**Q:** Этот код сортирует массив по алфавиту. Максимально упростите замыкание.

```swift
var animals = ["fish", "cat", "chicken", "dog"]
animals.sort { (one: String, two: String) -> Bool in
    return one < two
}
print(animals)
```

**A:** Swift автоматически определяет тип параметров замыкания и возвращаемый тип, так что вы можете убрать их:

```swift
animals.sort { (one, two) in return one < two }

//Вы можете заменить имена параметров использованием нотации $i:

animals.sort { return $0 < $1 }

//Замыкания, состоящие из одного оператора, могут не содержать ключевое слово return. 
//начение последнего выполненного оператора становится возвращаемым результатом замыкания:

animals.sort { $0 < $1 }

//Наконец, так как Swift знает, что элементы массива соответствуют протоколу Equatable, вы можете просто написать:

animals.sort(by: <)

//В данном случае можно еще короче:
 animals.sort()
//– сортирует по возрастанию, работает для типов, реализующих Comparable.
```

------



**Q:** Этот код создаёт два класса: Address и Person. Также создаются два экземпляра класса Person (Ray и Brian).

```swift
class Address {
  var fullAddress: String
  var city: String

  init(fullAddress: String, city: String) {
    self.fullAddress = fullAddress
    self.city = city
  }
}

class Person {
  var name: String
  var address: Address

  init(name: String, address: Address) {
    self.name = name
    self.address = address
  }
}

var headquarters = Address(fullAddress: "123 Tutorial Street", city: "Appletown")
var ray = Person(name: "Ray", address: headquarters)
var brian = Person(name: "Brian", address: headquarters)
```

Предположим, что Brian переехал по новому адресу и вы хотите обновить его запись следующим образом:

```swift
brian.address.fullAddress = "148 Tutorial Street"
```

Это компилируется и выполняется без ошибок. Но, если вы проверите теперь адрес Ray, то вы увидите, что он тоже «переехал».

Что здесь произошло и как мы можем исправить это?

**A:** Address — это класс и обладает ссылочной семантикой. Таким образом, headquarters — это один и тот же экземпляр класса, который разделяют ray и brian. 
Изменение headquarters изменит адрес обоих.
Чтобы исправить это, можно создать новый экземпляр класса Address и присвоить его Brian, или объявить Address как struct вместо class.

------



**Q:** Что такое `optional` и какие проблемы они решают?

**A:** Optional это enum, содержащий два кейса:
`Optional.none` is equivalent to the `nil` literal.
`Optional.some(Wrapped)` stores a wrapped value.

Optional позволяет переменной любого типа представить ситуацию "отсутствие значения". 
В Objective-C «отсутствие значения» было доступно только в ссылочных типах с использованием специального значения nil. У типов-значений (value types), вроде int или float, такой возможности не было.
Swift расширил концепцию «отсутствия значения» на типы-значения. Переменная optional может содержать либо значение, либо nil, сигнализирующее об отсутствии значения.

------



**Q:** Коротко перечислите основные отличия между `structure` и `class`.

**A:** Классы поддерживают наследование, а структуры — нет.
Классы — ссылочный тип, структуры — тип-значение.

------



**Q:** Что такое `generics` и для чего они нужны?

**A:** В Swift вы можете использовать generics в классах, структурах и перечислениях.

Generics устраняют проблему дублирования кода. Если у вас есть метод, который принимает параметры одного типа, иногда приходится дублировать код, 
чтобы работать с параметрами другого типа.
Позволяет писать универсальные, гибкие функции, работающие с разными типами 

В `Objective-C` есть только `lightweight generics`
Являются универсальным шаблоном
Механизм работает в момент компиляции

Например, в этом коде вторая функция — это «клон» первой, за исключением того, что у неё параметры string, а не integer.

```swift
func areIntEqual(_ x: Int, _ y: Int) -> Bool {
  return x == y
}

func areStringsEqual(_ x: String, _ y: String) -> Bool {
  return x == y
}

areStringsEqual("ray", "ray") // true
areIntEqual(1, 1) // true
```

Применяя generics, вы совмещаете две функции в одной и одновременно обеспечиваете безопасность типов:

```swift
func areTheyEqual<T: Equatable>(_ x: T, _ y: T) -> Bool {
  return x == y
}

areTheyEqual("ray", "ray")
areTheyEqual(1, 1)
```

Так как вы тестируете равенство, вы ограничиваете типы теми, которые отвечают протоколу `Equatable`. 
Этот код обеспечивает требуемый результат и препятствует передаче параметров неподходящего типа.

------



**Q:** В некоторых случаях не получится избежать неявного разворачивания (implicitly unwrapped) optionals. Когда и почему?

**A:** Наиболее частые причины для использования implicitly unwrapped optionals:
когда вы не можете инициализировать свойство, которое не nil в момент создания. Типичный пример — outlet у Interface Builder, который всегда инициализируется после его владельца. В этом особенном случае, если в Interface Builder всё правильно сконфигурировано — вам гарантировано, 
что outlet не-nil перед его использованием.
Чтобы разрешить проблему цикла сильных ссылок, когда два экземпляра классов ссылаются друг на друга и требуется не-nil ссылка на другой экземпляр. 
В этом случае вы помечаете ссылку на одной стороне как unowned, а на другой стороне используете неявное разворачивание optional.

------



**Q:** Какими способами можно развернуть optional? Оцените их в смысле безопасности.

```swift
var x : String? = "Test"
```

**A:** 

```swift
//Принудительное развёртывание (forced unwrapping) — небезопасно.
let a: String = x!

//Неявное развертывание при объявлении переменной — небезопасно.
var a = x!
```

```swift
//Optional binding — безопасно.
if let a = x {
  print("x was successfully unwrapped and is = \(a)")
}

//Optional chaining — безопасно.
let a = x?.count

//Nil coalescing operator — безопасно.
let a = x ?? ""

//Оператор Guard — безопасно.
guard let a = x else {
  return
}

//Optional pattern — безопасно.
if case let a? = x {
  print(a)
}
```

------



**Q:** В чём разница между `nil и .none?`

**A:** Нет никакой разницы, Optional.none (кратко .none) и nil эквивалентны.
Фактически, следующий оператор вернёт true:
`nil == .none`
Использование nil более общепринято и рекомендовано.

------



**Q:** Здесь модель термометра в виде класса и структуры. Компилятор жалуется на последнюю строчку. Что там не так?

```swift
public class ThermometerClass {
  private(set) var temperature: Double = 0.0
  public func registerTemperature(_ temperature: Double) {
    self.temperature = temperature
  }
}

let thermometerClass = ThermometerClass()
thermometerClass.registerTemperature(56.0)

public struct ThermometerStruct {
  private(set) var temperature: Double = 0.0
  public mutating func registerTemperature(_ temperature: Double) {
    self.temperature = temperature
  }
}

let thermometerStruct = ThermometerStruct()
thermometerStruct.registerTemperature(56.0)
```

**A:** ThermometerStruct корректно объявлен с mutating функцией для изменения внутренней переменной. Компилятор жалуется на то, что вы вызываете метод registerTemperature экземпляра, который был создан при помощи let, таким образом, этот экземпляр неизменяемый (immutable). 
Изменение let на var исправит ошибку компиляции.

В структурах вы должны помечать методы, которые изменяют внутренние переменные, как mutating, но вы не можете вызывать эти методы, используя immutable экземпляр.

------



**Q:** Что выведет этот код и почему?

```swift
var thing = "cars"
let closure = { [thing] in
  print("I love \(thing)")
}
thing = "airplanes"

closure()
```

**A:** Будет напечатано: I love cars. Список захвата создаст копию переменной в момент объявления замыкания. Это означает, что захваченная переменная не изменит своего значения, даже после присвоения нового значения.
Если вы опустите список захвата в замыкании, то компилятор будет использовать ссылку, а не копию. Вызов замыкания отразит изменение в переменной:

```swift
var thing = "cars"

let closure = {    
  print("I love \(thing)")
}

thing = "airplanes"

closure() // Prints: "I love airplanes"
```

------



**Q:** Это функция, которая считает количество уникальных значений в массиве:

```swift
func countUniques<T: Comparable>(_ array: Array<T>) -> Int {
  let sorted = array.sorted()
  let initial: (T?, Int) = (.none, 0)
  let reduced = sorted.reduce(initial) {
    ($1, $0.0 == $1 ? $0.1 : $0.1 + 1)
  }
  return reduced.1
}
```

Она использует sorted, так что она использует только типы, соответствующие протоколу Comparable.

Вы можете вызвать ее так:

```swift
countUniques([1, 2, 3, 3]) // результат 3
```


Перепишите эту функцию как расширение Array, чтобы можно было использовать так:

```swift
[1, 2, 3, 3].countUniques() // должна вывести 3
```

> примечание переводчика
> Что-то уж больно монструозная функция. Почему бы не так:

```swift
func countUniques<T: Hashable>(_ array: Array<T>) -> Int {
    return Set(array).count
}
```

**A:** 

```swift
extension Array where Element: Comparable {
  func countUniques() -> Int {
    let sortedValues = sorted()
    let initial: (Element?, Int) = (.none, 0)
    let reduced = sortedValues.reduce(initial) { 
      ($1, $0.0 == $1 ? $0.1 : $0.1 + 1) 
    }
    return reduced.1
  }
}
```

------



**Q:** Вот функция, которая делит два optional doubles. Есть три условия, которые должны соблюдаться:
делимое не должно быть nil
делитель не должен быть nil
делитель не должен быть равен 0

```swift
func divide(_ dividend: Double?, by divisor: Double?) -> Double? {
  if dividend == nil {
    return nil
  }
  if divisor == nil {
    return nil
  }
  if divisor == 0 {
    return nil
  }
  return dividend! / divisor!
}
```

Перепишите эту функцию, используя оператор `guard` и не используя принудительное развёртывание (forced unwrapping).
**A:** Оператор guard, появившийся в Swift 2.0, обеспечивает выход в случае не соблюдения условия. Вот пример:

```swift
guard dividend != nil else { return nil }
```


Вы также можете использовать оператор `guard` для `optional binding`, после чего развернутая переменная будет доступна и за пределами оператора guard:

```swift
guard let dividend = dividend else { return .none }

//Таким образом, вы можете переписать функцию так:

func divide(_ dividend: Double?, by divisor: Double?) -> Double? {
  guard let dividend = dividend else { return nil }
  guard let divisor = divisor else { return nil }
  guard divisor != 0 else { return nil }
  return dividend / divisor
}
```

Обратите внимание на отсутствие принудительной распаковки, так как мы уже распаковали делимое и делитель и поместили их в non-optional immutable переменные.

Обратите также внимание на то, что результат распакованных optionals в операторе guard доступен и за пределами оператора guard.

Вы можете еще больше упростить функцию путем группировки операторов guard:

```swift
func divide(_ dividend: Double?, by divisor: Double?) -> Double? {
  guard 
    let dividend = dividend,
    let divisor = divisor,
    divisor != 0 
    else { 
      return nil 
    }
  return dividend / divisor
}
```

------



**Q:** В Objective-C вы объявляете константу таким образом:

`const int number = 0;`

А так в Swift:

`let number = 0`

В чём тут разница?

**A:** В Objective-C константа инициализируется во время компиляции значением, которое должно быть известно на этом этапе.

Неизменяемое значение, созданное при помощи let — это константа, определяемая на этапе выполнения. Вы можете инициализировать ее статическим или динамическим выражением. Поэтому мы можем делать так:

```swift
let higherNumber = number + 5
```

Обратите внимание: такое присвоение возможно сделать лишь однажды.

------



**Q:** Чтобы объявить статическое свойство или функцию для типов-значений, используется модификатор static. Вот пример для структуры:

```swift
struct Sun {
  static func illuminate() {}
}
```

А для классов возможно использовать модификаторы static или class. Результат один и тот же, но есть отличие. Опишите его.

**A:** static делает свойство или функцию статической и непереопределяемой. Использование class позволит переопределять свойство или функцию.

Здесь компилятор будет ругаться на попытку переопределить illuminate():

```swift
class Star {
  class func spin() {}
  static func illuminate() {}
}
class Sun : Star {
  override class func spin() {
    super.spin()
  }
  // error: class method overrides a 'final' class method
  override static func illuminate() { 
    super.illuminate()
  }
}
```

------



**Q:** Можно ли добавить `stored property` к типу, используя `extension?` Каким образом или почему нет?

**A:** Нет, это невозможно. Мы можем использовать extension, чтобы добавить новое поведение существующему типу, но не можем изменить сам тип или его интерфейс. 
Для хранения нового stored property нам потребуется дополнительная память, а extension не может это сделать.

------



**Q:** Что такое протокол в Swift?

**A:** Протокол — это тип, который определяет набор методов, свойств и т.д. Класс, структура или перечисление могут принимать протокол, чтобы реализовать все это. 
Протокол сам по себе не реализует функционал, но определяет его.

- Определяет интерфейс взаимодействия
- Является абстракцией
- Адаптируется классами, структурами и перечислениями 
- Может иметь дефолтную реализацию методов
- По сути реализует множественное наследование

------



**Q:** Замыкания — это ссылочный тип или тип-значение?

**A:** `Замыкания — это ссылочный тип`. Если вы присваиваете переменной замыкание, а затем копируете в другую переменную, вы копируете ссылку на то же самое замыкание и его список захвата.

------



**Q:** Вы используете тип UInt для хранения беззнакового целого. Он реализует инициалайзер для конвертации из целого со знаком:

`init(_ value: Int)`

Однако, следующий код не скомпилируется, если вы зададите отрицательное значение:

```swift
let myNegative = UInt(-1)
```

Целые со знаком по определению не могут быть отрицательными. Однако, возможно использовать представление отрицательного числа в памяти для перевода его в беззнаковое.

Как можно сконвертировать отрицательное целое в UInt с сохранением его представления в памяти?

**A:** Для этого есть инициалайзер:

`UInt(bitPattern: Int)`


И использование:

```swift
let myNegative = UInt(bitPattern: -1)
```

------



**Q:** Опишите циклические ссылки в Swift? Как их можно исправить?

**A:** Циклические ссылки происходят, когда два экземпляра содержат сильную ссылку друг на друга, что приводит к утечке памяти из-за того, что ни один из этих экземпляров не может быть освобождён. Экземпляр не может быть освобождён, пока есть еще сильные ссылки на него, но один экземпляр держит другой. 

Это можно разрешить, заменив на одной из сторон ссылку, указав ключевое слово weak или unowned.

------



**Q:** Swift разрешает создавать рекурсивные перечисления. Вот пример такого перечисления, которое содержит вариант Node с двумя ассоциативными типами, T and List:

```swift
enum List<T> {
  case node(T, List<T>)
}
```

Здесь будет ошибка компиляции. Что мы пропустили?

**A:** Мы забыли ключевое слово indirect, которое позволяет подобные рекурсивные варианты перечисления:

```swift
enum List<T> {
  indirect case node(T, List<T>)
}
```

------



**Q:** Допустим, у нас есть структура, определяющая модель термометра:

```swift
public struct Thermometer {
  public var temperature: Double
  public init(temperature: Double) {
    self.temperature = temperature
  }
}
```

Чтобы создать экземпляр, мы пишем:

`var t: Thermometer = Thermometer(temperature:56.8)`

Но было бы гораздо удобнее что-то вроде этого:

`var thermometer: Thermometer = 56.8`

Возможно ли это? Как?

**A:** Swift определяет протоколы, которые позволяют инициализировать тип с использованием литералов путем присваивания. Применение соответствующего протокола и обеспечение публичного инициалайзера позволит инициализацию при помощи литералов. В случае Thermometer мы реализуем ExpressibleByFloatLiteral:

```swift
extension Thermometer: ExpressibleByFloatLiteral {
  public init(floatLiteral value: FloatLiteralType) {
    self.init(temperature: value)
  }
}
//Теперь мы можем создать экземпляр вот так:
var thermometer: Thermometer = 56.8
```

------



**Q:** Чем `абстрактный класс` отличается от `интерфейса`?

**A:** Интерфейс - такой же `абстрактный класс`, только в нем не может быть свойств и не определены тела у методов. Так же стоит заметить, что `абстрактный класс` наследуется(etxends), а `интерфейс` реализуется (implements). Вот и возникает разница между ними, что наследовать мы можем только *1 класс*, а реализовать сколько угодно.

`Абстрактный класс` — это класс, у которого не реализован один или больше методов (некоторые языки требуют такие методы помечать специальными ключевыми словами).

`Интерфейс` — это абстрактный класс, у которого ни один метод не реализован, все они публичные и нет переменных класса.

Интерфейс нужен обычно когда описывается только интерфейс (тавтология). Например, один класс хочет дать другому возможность доступа к некоторым своим методам, но не хочет себя «раскрывать». Поэтому он просто реализует интерфейс.

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего. Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.

**Можно считать, что любой интерфейс — это уже абстрактный класс, но не наоборот.**

Интерфейсы, в отличии от абстрактных классов, поддерживают множественное наследование. Т.е. класс-потомок может реализовывать 2 или более интерфейсов одновременно: class A implements Int1, Int2, но class A extends AbstrB

Интерфейс содержит исключительно объявления методов, но не содержит реализации. Абстрактный класс же может содержать как абстрактные методы (без реализации), так и обыкновенные.

Интерфейс не может включать в себя свойства, в абстрактном классе, как и в любом другом, свойства могут присутствовать.

Класс-потомок обязан реализовывать все методы интерфейса, методы абстрактного класса же могут в нем не присутствовать.

В интерфейсе все методы открытые, в абстактном классе они могут содержать спецификаторы доступа (private, protected, pubic).

```
Абстрактный класс - может иметь поля, методы, но имеет хотя бы один абстрактный (не определенный) метод. 

Интерфейс - чистый абстрактный класс, в котором не может быть свойств и не определены методы.

От абстрактного класса наследуются и реализуют абстрактный метод.

Интерфейс реализуют или полностью, или частично (тогда это будет новый абстрактный класс).
```

------



**Q:** Расскажите о `паттерне MVC`. Чем отличается `пассивная` модель от `активной`?

**A:** `MVC` - model(модель)-view(представление, вид)-controller(контроллер) - паттерн, в котором модель приложения, пользовательский интерфейс и взаимодействие с пользователем разделены и насколько возможно независимы. 

Пассивная модель — модель не имеет никаких способов воздействовать на представление или контроллер, и пользуется ими в качестве источника данных для отображения. Все изменения модели отслеживаются контроллером и он же отвечает за перерисовку представления, если это необходимо. Такая модель чаще используется в структурном программировании, так как в этом случае модель представляет просто структуру данных, без методов их обрабатывающих.

Активная модель оповещает вид о произошедших изменениях, а вид, которому нужно знать о изменениях, следит за этими изменениями. В этом случае достигается независимость модели как от контроллера, так и от вида.

------



**Q:** Реализация `синглтона (Singleton)` в `ARC` и в `non-ARC`?

**A:** `Singleton` - породающий шаблон, который гарантируюет, что в однопоточном приложении будет единственный экземпляр класса с глобальной точкой доступа. 

Может последовать вопрос: "Почему бы не использовать статические методы класса?" Ответ: Статические методы класса не дают широкую функциональность в отличие от единственного объекта класса. 

Кроме того, в будущем может понадобится несколько объектов. 

Реализация без `ARC`:

```swift
+ (Singleton *)sharedInstance {
    static Singleton *sharedInstance = nil;
    @synchronized(self) {
        if (!sharedInstance) {
            sharedInstance = [[Singleton alloc] init];
        }
    }
    return sharedInstance;
}
```

Реализация c помощью `ARC`:

```swift
+ (Singleton *)sharedInstance {
    static dispatch_once_t pred;
    static Singleton *sharedInstance = nil;
 
    dispatch_once(&pred, ^{ sharedInstance = [[self alloc] init]; });
    return sharedInstance;
}
```

------



**Q:** Какие еще `паттерны` знаете?

**A:** Патерны поведения и взаимодействия объектов (Behavioral):

- [Стратегия](https://refactoring.guru/ru/design-patterns/strategy) (Strategy)
- [Состояние](https://refactoring.guru/ru/design-patterns/state) (State)
- [Команда](https://refactoring.guru/ru/design-patterns/command) (Command)
- [Итератор](https://refactoring.guru/ru/design-patterns/iterator) (Iterator)
- [Посредник](https://refactoring.guru/ru/design-patterns/mediator) (Mediator)
- [Наблюдатель](https://refactoring.guru/ru/design-patterns/observer) (Observer)
- [Посетитель](https://refactoring.guru/ru/design-patterns/visitor) (Visitor)
- [Снимок](https://refactoring.guru/ru/design-patterns/memento) (Memento)
- [Цепочка обязанностей](https://refactoring.guru/ru/design-patterns/chain-of-responsibility) (Chain of Responsibility)
- [Шаблонный метод](https://refactoring.guru/ru/design-patterns/template-method) (Template Method)

Структурные паттерны (Structural):

- [MVC](https://habrahabr.ru/post/215605/) (Модель-Представление-Контроллер) и его разновидности
- [Компоновщик](https://refactoring.guru/ru/design-patterns/composite) (Composite)
- [Декоратор](https://refactoring.guru/ru/design-patterns/decorator) (Decorator)
- [Адаптер](https://refactoring.guru/ru/design-patterns/adapter) (Adapter)
- [Заместитель](https://refactoring.guru/ru/design-patterns/proxy) (Proxy)
- [Фасад](https://refactoring.guru/ru/design-patterns/facade) (Facade)
- [Мост](https://refactoring.guru/ru/design-patterns/bridge) (Bridge)
- [Легковес](https://refactoring.guru/ru/design-patterns/flyweight) (Flyweight)

Порождающие паттерны, паттерны создания объектов (Creational):

- [Singleton ](https://refactoring.guru/ru/design-patterns/singleton)(Одиночка)

- [Fabric method](https://refactoring.guru/ru/design-patterns/factory-method) (Фабричный метод)

- [Abstarct Factory](https://refactoring.guru/ru/design-patterns/abstract-factory) (Абстрактная фабрика)

- [Builder](https://refactoring.guru/ru/design-patterns/builder) (Строитель)

- [Прототип](https://refactoring.guru/ru/design-patterns/prototype) (Prototype)

  ------

  

#### Паттерны проектирования (поведенческие)

**Цепочка обязанностей (chain of responsibility)**
Избегает связывания отправителя запроса и его получателя, давая возможность обработать запрос более чем одному объекту. Связывает объекты-получатели и передаёт запрос по цепочке пока объект не обработает его.

------

**Команда (command)**
Инкапсулирует запрос в виде объекта, позволяя передавать их клиентам в качестве параметров, ставить в очередь, логировать, а также поддерживает отмену операций.

------

**Интерпретатор (interpreter)**
Получая формальный язык, определяет представление его грамматики и интерпретатор, использующий это представление для обработки выражений языка.

------

**Итератор (iterator)**
Предоставляет способ последовательного доступа к элементам множества, независимо от его внутреннего устройства.

------

**Посредник (mediator)**
Определяет объект, инкапсулирующий способ взаимодействия объектов. Обеспечивает слабую связь, избавляя объекты от необходимости прямо ссылать друг на друга и даёт возможность независимо изменять их взаимодействие.

------

**Хранитель (memento)**
Не нарушая инкапсуляцию, определяет и сохраняет внутреннее состояние объекта и позволяет позже восстановить объект в этом состоянии.

------

**Наблюдатель (observer)**
Определяет зависимость «один-ко-многим» между объектами так, что когда один объект меняет своё состояние, все зависимые объекты оповещаются.

------

**Состояние (state)**
Позволяет объекту изменять своё поведение в зависимости от внутреннего состояния.

------

**Стратегия (strategy)**
Определяет группу алгоритмов, инкапсулирует их и делает взаимозаменяемыми. Позволяет изменять алгоритм независимо от клиентов, его использующих.

------

**Шаблонный метод (template method)**
Определяет алгоритм, некоторые этапы которого делегируются подклассам. Позволяет подклассам переопределить эти этапы, не меняя структуру алгоритма.

------

**Посетитель (visitor)**
Представляет собой операцию, которая будет выполнена над объектами группы классов. Даёт возможность определить новую операцию без изменения кода классов, над которыми эта операция проводится.

------

------

#### Паттерны проектирования (структурные)

**Адаптер (adapter)**
Конвертирует интерфейс класса в другой интерфейс, ожидаемый клиентом. Позволяет классам с разными интерфейсами работать вместе.

------

**Мост (bridge)**
Разделяет абстракцию и реализацию так, чтобы они могли изменяться независимо.

------

**Компоновщик (composite)**
Компонует объекты в древовидную структуру, представляя их в виде иерархии. Позволяет клиенту обращаться как к отдельному объекту, так и к целому поддереву.

------

**Декоратор (decorator)**
Динамически предоставляет объекту дополнительные возможности. Представляет собой гибкую альтернативу наследованию для расширения функциональности.

------

**Фасад (facade)**
Предоставляет единый интерфейс к группе интерфейсов подсистемы. Определяет высокоуровневый интерфейс, делая подсистему проще для использования.

------

**Приспособленец (flyweight)**
Благодаря совместному использованию, поддерживает эффективную работу с большим количеством объектов.

------

**Прокси (proxy)**
Предоставляет замену другого объекта для контроля доступа к нему.

------

------

#### Паттерны проектирования (порождающие)

------

**Абстрактная фабрика (abstract factory)**
Предоставляет интерфейс для создания групп связанных или зависимых объектов, не указывая их конкретный класс.

------

**Строитель (builder)**
Разделяет создание сложного объекта и инициализацию его состояния так, что одинаковый процесс построения может создать объекты с разным состоянием.

------

**Фабричный метод (factory method)**
Определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать. Позволяет делегировать создание объекта подклассам.

------

**Прототип (prototype)**
Определяет несколько видов объектов, чтобы при создании использовать объект-прототип и создаёт новые объекты, копируя прототип.

------

**Одиночка (singleton)**
Гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к нему.

------

------



**Q:** Как работают `push нотификации`?

**A:** iOS запрашивает у сервера Apple Push Notification Service (APNS) токен девайса. Приложение получает токен девайса. Можно считать, что токен – это адрес для отправки push-уведомлений. Приложение отправляет токен девайса на ваш сервер. Когда произойдёт какое-либо событие для вашего приложения, сервер отправит push-уведомление в APNS. APNS отправит push-уведомление на девайс пользователя.

Тонкие моменты при работе с push-уведомлениями:

- Они не надёжны! Нет гарантий, что push-уведомления будут доставлены, даже если APNS примет их.
- Как только ваш сервер сформировал push-уведомление, он безответно отправляет его в APNS. Нет способа узнать статус доставки уведомления конечному пользователю после отправки. Время доставки может варьироваться от нескольких секунд до получаса.
- Кроме этого, у пользователей i-девайсов может не быть возможности получать push-уведомления всё время. Например, рядом нет Wi-Fi сети с доступом в интернет либо девайс может быть вообще выключен.
- APNS будет пытаться доставить последнее отправленное уведомление, когда девайс станет доступен для приёма. Но эти попытки ограничены по времени. После тайм-аута push-уведомление будет потеряно навсегда!
- Они могут быть дорогими! Добавить push-функционал в приложение довольно просто и недорого, если вы владеете данными. Однако если у вас много пользователей либо необходимо запрашивать данные, то затраты резко возрастают.

**Тонкости Push-Notification**

1. **Не работают в симуляторе**, поэтому для тестирования нужен настоящий девайс;
2. Регистрация в **iOS Developer Program**;
   Для каждого приложения, в котором будет интегрирован механизм push-уведомлений, необходимо создать новый **App ID** и **provisioning profile**, а также **SSL-сертификат** для сервера;
3. **Размер полезной нагрузки** не может превышать **256 байт**. Это примерно столько же, сколько позволяет вместить в себя СМС или твит;
4. **Нет гарантий**, что push-уведомления будут доставлены, даже если APNS примет их;
5. Как только ваш сервер сформировал push-уведомление, он **безответно отправляет** его в APNS. **Нет способа узнать статус доставки** уведомления конечному пользователю после отправки. **Время**доставки может варьироваться **от нескольких секунд до получаса**;
6. **APNS** будет пытаться доставить последнее отправленное уведомление, когда девайс **станет доступен **для приёма. После тайм-аута push-уведомление будет потеряно навсегда;

------



**Q:** Что такое `responder chain`?

**A:** Это цепочка по которой проходит событие от отправителя к получателю, от First Responder, по иерархии контроллеров, до root view controller, window object и последнего - app object.

Поведенческий шаблон проектирования, реализуемый в UIKit
Все представления, наследники UIResponder, участвуют в цепочке зависимости

Существует понятие first responder. Его можно переопределить, но обычно это View на которую был совершен tap event
Next responder - следующее View в иерархии, то есть его родитель. Цепочка будет продолжаться до View, ассоциируемого с ViewController’ом. Если данный ViewController - root, то далее по цепочке будет идти UIWindow. Next responder у UIWindow - это UIApplication. Последним в цепочке будет AppDelegate

```
-UIControl Actions(например, нажатие кнопки)
-User events: (touches, shakes, motion, etc...)
-System events: (low memory, rotation, etc...)
```

https://habr.com/ru/post/464463/

------



**Q:** Опишите `основные понятия ООП` в терминах Objective-C (`интерфейс, реализация, свойства, протоколы,` и т.д)

**A:** Определение класса начинается с ключевого слова `@interface`, после чего следует имя класса и тело класса, заключенная в фигурных скобках. В Objective-C все классы унаследованы от основного класса NSObject. Это родительский класс всех классов в Objective-С. Он обеспечивает основные методы: выделение памяти, инициализация. Ниже приведен пример определения класса Box:

```objective-c
 @interface Box:NSObject
 {
     //Instance variables
     double m_length;   // Length of a box
     double m_breadth;  // Breadth of a box
 }
 @end
```

`Свойство` - это переменная экземпляра, объединенная с автогенераторами и сеттерами. 

`Протоколы` в Objective-C описывают методы, которые должны реализовать классы принимающие эти протоколы. Методы описанные в протоколе не имеют собственной реализации, они реализуются в принимающем протокол классе. В других языках программирования протоколы известны как абстрактные классы и интерфейсы.
Описание протокола начинается с директивы **@protocol**, за которой следует имя протокола. После этого описываются методы. Описание протокола заканчивается директивой **@end**
Протокол может описывать методы, которые должны быть реализованы обязательно или опционально. По умолчанию, все методы, описанные в протоколе, являются обязательными.
Так, методы описанные в примере являются обязательными для реализации. Также обязательные для реализации методы можно пометить с помощью директивы @requried
Протокол может быть унаследован от произвольного количества других протоколов. Названия наследуемых протоколов задается в угловых скобках , после имени описываемого протокола

`Категории` в Objective-C - это механизм позволяющий расширять существующие классы. Используя категории к классу можно добавить новые методы без применения наследованная и не имея исходников изменяемого класса. Добавляемые таким способом методы становятся доступными всем классам, унаследованным от изменяемого. С помощью категорий также можно переопределять существующие методы. Категория имеет доступ к переменным экземпляра исходно класса, однако с помощью категорий невозможно добавить новые переменные экземпляра.

*Методы описанные в категории необязательны для реализации.* 
Категория с описанными, но не реализованными методами называется неформальным протоколом. Неформальные протоколы часто определяются для корневого класса `NSObject`, при этом они не имеют реализации в самом классе. Каждый подкласс будет отвечать на сообщения описанные в категории, но при этом будут делать что-то полезное только реализованные методы. Методы, по мере необходимости, могут быть реализованы в подклассах, при этом реализуемые методы должны быть объявлены в секции `@interface`.

```objective-c
@interface Начинает объявление класса или категории (категория – расширение класса дополнительными методами без наследования)
@implementation Начинает определение класса или категории
@protocol Начинает объявление протокола (аналог класса С++, состоящего из чисто виртуальных функций)
@end Завершает объявление\определение любого класса, категории или протокола
@private Ограничивает область видимости инвариантов класса методами класса (аналогично С++)
@protected Стоит по умолчанию. Ограничивает область видимости инвариантов класса методами класса и методами производных классов (аналогично С++)
@public Удаляет ограничения на облать видимости (аналогично С++)
@try Определяет блок с возможной генерацией исключений (аналогично С++)
@throw Генерирует объект-исключение (аналогично С++)
@catch () Обрабатывает исключение, сгенерированное в предшествующем блоке @try (аналогично С++)
@finally Определяет блок после блока @try, в который предается куправление независимо от того, было или нет сгенерировано исключение
@class Сокращенная форма объявления класса (только имя (аналогично С++))
@selector(method_name) Возвращает скомпилированный селектор для имени метода method_name
@protocol(protocol_name) Ворзвращает экземпляр класса-протокола с именем protocol_name
@encode(type_spec) Инициализирует строку символов, которая будет использована для шифрования данных типа type_spec
@synchronized() Определяет блок кода, выполняющегося только одной нитью в любой определенный момент времени
```

------



**Q:** Что такое назначеный инициализатор (designated initializer).
**A:** Назначенный инициализатор (designated initializer) - это главный инициализатор(конструктор), все остальные методы, создающие класс, вызывают этот метод.

##### Как выглядит назначенный инициализатор?

У объектов бывает сразу несколько методов начинающихся с init, например init, initWithName, 
initWithName:balance: и тд

Установившейся практикой в таком случае является выделение среди всех init-методов одного, 
назвыемого designated initializer. Все остальные init-методы должны вызывать его и только он
вызывает унаследованный init-метод.

В нашем случае designated initializer будет -initWithName:balance:

```objective-c
-(id)init {
   if (self = [super init]) { // equivalent to "self does not equal nil"
       date = [[NSDate date] retain];
   }
   return self;
 }
```

------



**Q:** Суть `рантайма (Runtime), отправление сообщения`

**A:** Objective-C - это динамический язык. Objective-C это `формально не язык`, а `надстройка над C`. И в C нет классов. Поэтому все эти свойства даже которые спрятаны и не видны пользователям - `легко достать`.

В `Runtime` мы можем получить все скрытое. И когда мы говорим о Runtime для потребительских целей мы говорим о способе достать все скрытые свойства

**Суть рантайма (Runtime)?**

```
1. Отправление сообщения - сишные функции, которые производят 

2. Манипулирование классами(class_addMethod, class_addIvar, class_replaceMethod), 

3. Cоздание новых классов (class_allocateClassPair, class_registerClassPair),

4. Интроспекция (class_getName, class_getSuperclass, class_getInstanceVariable,
class_getProperty, class_copyMethodList, class_copyIvarList, class_copyPropertyList), 

5. Манипулирование объектами (objc_msgSend, objc_getClass, object_copy),

6. Работу с ассоциативными ссылками 
```

##### Отправка сообщений

```
[array insertObject:foo atIndex:1]; -> objc_msgSend(array, @selector(insertObject:atIndex:), foo, 1);
```

##### Ассоциативные ссылки

```
objc_setAssociatedObject(self, &key, newProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
objc_getAssociatedObject(self, &key);
```

Runtime - предоставляет набор функций в системе исполнения для выполнения скомпилированного кода. Автоматический поиск переменных/методов. Apple уже реализовало это в виде Key-Value Coding: вы задаете имя, в соответсвии с этим именем получаете переменную или метод. Вы можете делать это и сами, если вас чем-то не устраивает реализация Apple. Автоматическая регистрация/вызов подклассов. Используя objc_getClassList вы можете получить список классов, уже известных Runtime и, проследив иерархию классов, выяснить, какие подклассы наследуются из данного класса. Это дает вам возможность писать подклассы, которые будут отвечать за специфичиские форматы данных, или что-то в этом роде, и потом дать суперклассу возможность находить их самому, избавив себя от утомительной необходимости регистрировать их все руками. 
Автоматически вызвывать метод для каждого класса. Это может быть полезно для unit-testing фреймворков и подобного рода вещей. Перегрузка методов во время исполнения. Runtime предоставляет вам полный набор инструментов для изменения реализации методов классов, без необходимости изменять что-либо в их исходном коде 
Bridging Имея возможность динамически создавать классы и просматривать необходимые поля, вы можете создать мост между Objective-C и другим (достаточно динамичным) языком.

В Objective-C каждый вызов метода транслируется в соответствующий вызов функции objc_msgSend:

```
// Вызов метода
[array insertObject:foo atIndex:1];
// Соответствующий ему вызов Runtime-функции
objc_msgSend(array, @selector(insertObject:atIndex:), foo, 1);
```

Вызов objc_msgSent инициирует процесс поиска реализации метода в кеш таблице методов класса вверх по иерархии наследования — в суперклассах данного класса. Если же и при поиске по иерархии результат не достигнут, запускается динамический поиск — вызывается один из специальных методов: resolveInstanceMethod или resolveClassMethod. Этот механизм позволяет реализовать Method Swizzling.

Swift Runtime

In short there are Dynamic and Static types of method call dispatching.

1. Static - the function address to be called is determined in the compilation time, so that expense of such call is similar to C-function calling. This mechanism is used for `private` methods or `final` classes methods call dispatching. 

2. Dynamic dispatching is mechinism which allows to implement polymorphism concept of OOP - the function address to be called is determined in running time. Swift has two subtypes of it:

   2.1. Obj-C - you already described in the question. This mechanism is used when object inherits from NSObject or calling method has @objc prefix.

   2.2. Virtual table based (like in C++) - there is similar witness tables. What it does during method call dispatching is just single arithmetic operation - calculation of actual function address based on function offset in the base class witness table and the object class witness table location. So that's a relatively cheap operation comparing to Obj-C. It explains why "pure" Swift approximates to C++ performance.

If you don't mark you method with `private` keyword or your class is not `final` and same time you class is "pure" Swift (it does not inherit NSObject) then this virtual table based mechanism is used. It means that all the methods by default are `virtual`. 

P.S. Helpful link for proving my vision regarding "Types":

https://developer.apple.com/swift/blog/?id=27

"Subtypes" explanation is based on my understanding.
https://github.com/apple/swift/blob/master/docs/Runtime.md

------



**Q:** Объявление `свойств (property)` `(retain, assign, nonatomic, readonly, copy)`. С подвохом: вопрос о несуществующем параметре `atomic`, что он означает? Как правильно реализовать сетер для свойства с параметром retain? Вопрос о циклах в графах владения, и почему свойства delegate (предоставляющие доступ к делегату) обычно задаются как `assign`?

**A:** 

```
retain - ручное управление памятью (устарело).
assign - для примитивов (для указателей будет тупое присваивание адреса).
copy - объект копируется в момент присваивания.
nonatomic - для работы в одном потоке, более быстрый.
atomic - потоко-безопасен, блокирует одновременный доступ, более медленный.
```

- **retain / strong** — показывает, что в сгенерированном сеттере счетчик ссылок на присваиваемый объект будет увеличен, а у объекта, на который свойство ссылалось до этого, — счетчик ссылок будет уменьшен. При включённом **ARC** используется **strong**, а при выключенном **ARC** используется **retain**;
- **copy** — означает, что мы копируем значение объекта при его создании. Также показывает, что полученное значение свойства будет иммутабельным, попытка изменения приведёт к крэшу;
- **assign** — просто присвоение адреса. С выключенным **ARC** является дефолтным значением. Стоит применять к свойствам типов, не попадающих под действие **ARC** (примитивные типы и так называемые необъектные типы (non-object types) вроде **CFTypeRef**);
- **unsafe_unretained** — свойство с таким типом владения просто сохраняет адрес присвоенного ему объекта. Методы доступа к такому свойству никак не влияют на счетчик ссылок объекта. Он может удалиться, и тогда обращение к такому свойству приведет к крэшу (потому и **unsafe**). Сейчас используется исключительно редко;
- **weak** — позволяет свойствам с таким значением атрибута менять свое значение на **nil**, когда объект, на который указывала переменная, уничтожается. Очень хорошо сказывается на устойчивости работы приложения;

Директива `@synthesize` автоматически генерирует set- и get-методы. Требует `dealloc` без ARC. @­synthesize property = _property; обязательно при одновременном переопределении set- и get-методов, для iVar не генерируется автоматически `@property` лишь генерирует сигнатуры геттера и мутатора. Но если свойство синтезированное (через `@synthesize` или по умолчанию), то кроме этого генерируется и ivar.

------



**Q:** В чем разница между `точечной нотацией` и использованием квадратных скобок? Что происходит когода мы пытаемся вызвать метод у nil указателя? Разница между nil и Nil?

**A:** При точечной нотации происходит диспетчеризация через геттер и сеттер (если они переопределены). 
Что происходит когода мы пытаемся вызвать метод у nil указателя? Ничего.

```
Это безопасно, поскольку не надо делать проверку объекта на nil.
```

objc_msgSend проверяет первый агрумент (получателя) и прерывается если получатель == nil

`точечная нотация` используется для обращения к свойствам обькта C использованием квадратных скобок - объекту посылается сообщение objc_msgSend

```
Разница между nil и Nil?

- NULL = (void \*)0 — нулевой указатель в языке Си;
- nil = (id)0 — нулевой указатель на объект Objective-C;
- Nil = (Class)0 — нулевой указатель типа Class в Objective-C;
- NSNull = [NSNull null] — синглтон класса NSNull — обёртки над nil и Null;
```

------



**Q:** Что такое `селектор (selector)`? Как его вызвать? как отложить вызов селектора? Что делать если селектор имеет много параметров? `(NSInvocation)` Как запустить селектор во второстепенном `(фоновом) потоке`?

**A:** это имя метода закодированное специальным образом, используемым Objective-c для быстрого поиска. Указание компилятору на селектор происходит при помощи директивы **@selector(метод)**

```
Это по сути строковое сообщение, которое посылается объекту, и он выполняет метод, ассоциированый с этим селектором.
```

Как его вызвать?

```
[self performSelector:@selector(method)];
```

Как отложить вызов селектора?

```
[self performSelector:@selector(method) withObject:obj afterDelay:delay];
```

Что делать если селектор имеет много параметров?

```
@selector(method:::) - двоиточий столько сколько параметров.
```

(NSInvocation)

```
Вызывает метод у объекта, можно менять параметры и цель.
```

Как запустить селектор во фоновом потоке?

```
[self performSelectorInBackground:selector withObject:obj];
```

------



**Q:** Как запустить `поток`? Что первым нужно сделать при запуске `потока`? `(NSAutoreleasePool)` Что такое `runLoop`, когда он используется? `(timers, nsurlconnection ...)`

**A:** [NSThread](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2) [NSThread detachNewThreadSelector:@selector(myThreadMainMethod:) toTarget:self withObject:nil];

[NSStream](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/CocoaStreamsOverview.html#//apple_ref/doc/uid/20002272-BABJFBBB)
NSAutoreleasePool пулы обеспечивают механизм, посредством которого можно отправить объекту "отложенные" release сообщения. Каждый поток в Cocoa приложении сохраняет свой собственный стек объектов NSAutoreleasePool

------



**Q:** Что такое `делегат (delegate)`? 

**A:** 

```
Делегат - объект который использует другой объект для реализации тех или иных функций.
```

**Делегирование** - это простой и мощный шаблон, в котором один объект в программе действует от имени или в координации с другим объектом. Делегирующий объект сохраняет ссылку на другой объект - делегат – и в соответствующее время отправляет ему сообщение. Сообщение информирует делегата о событии, которое делегируемый объект собирается обработать или только что обработал. Делегат может ответить на сообщение, обновив его внешний вид или состояние или другие объекты в приложении, и в некоторых случаях он может возвращать значение, которое влияет на обработку предстоящего события. Основная ценность делегирования заключается в том, что он позволяет легко настраивать поведение нескольких объектов в одном центральном объекте.
Объект, который использует другой объект для реализации тех или иных функций.
Другой вариант паттерна «Декоратор» — это [делегирование](http://habrahabr.ru/post/202960/). Механизм, при котором один объект взаимодействует от имени другого объекта (или в координации с ним).

- Как создать и [использовать](http://2tickets2dublin.com.ua/protocols_delegats_extensions_categories/) делегат?

> ```objective-c
> @required
> -(void)do_required;
> @optional
> -(void)do_optional;
> @end
> 
> @interface MyObject:NSObject
> @property (nonatomic, weak) id  <CustomProtocol> delegate; 
> @end
> ```

------



**Q:** Как представлены `структуры C` (CGRect, CGSize, CGPoint) в Objective-C?

**A:** Структура - это область в памяти, в которой содержаться ссылки на объекты (переменные).
`struct CGRect {}`, `typedef struct CGRect CGRect`

------



**Q:** Чем объект Objective-c отличается от структуры С, что такое структура в С.

**A:** В языке Си, структура (struct) — композитный тип данных, инкапсулирующий без сокрытия набор значений различных типов. Порядок размещения значений в памяти задаётся при определении типа и сохраняется на протяжении времени жизни объектов, что даёт возможность косвенного доступа (например, через указатели)

```objective-c
struct str_name
{
	int	member_1;
	float	member_2;
	char	member_3[256];
	/* ... */
};
```

Objective-c любую структуру данных, у которой есть указатель на класс в правильном местоположении, можно рассматривать как объект.

```objective-c
typedef struct objc_object {
   Class isa;
} *id;
```

------



**Q:** Какие существуют `root классы` в iOS? Для чего нужны `root классы`? Корневые классы: NSObject, NSProxy? Как работает proxy? Как эмитировать множественное наследование?

**A:** `NSPbject`, `NSProxy`, `Protocol`, `Class`.
В Objective-C два root классов - `NSObject` и `NSProxy`, которые является частью `Foundation framework.`

`NSObject` - корневой класс для всех классов, реализует базовую функциональность. Через `NSObject` объекты наследуют базовый интерфейс к `runtime`. 
`NSProxy` - позволяет преварительно конфигурировать группы объектов по определённым шаблонам.
Наследоваться от класса, который в свою очередь наследуется от другого класса и т.д.
`root класс` - это класс самого верхнего уровня наследования иерархии который не наследуется от любого другого класса. Он предоставляет базовый функционал всем остальным классам фреймворка. 

`NSProxy` реализует основные методы, необходимые из корневого класса, в том числе тех, которые определены в протоколе `NSObject`. В отличии от `NSObject` не предоставляет метода инициализации, и вызывает исключение при получении любого сообщения для которого нет обработчика.
`NSProxy` принимает сообщение и перенаправляет его реальному обьекту или вызывает загрузку реального обьекта (сам стает нужным обьектом)
**Objective-c не поддерживает множественное наследование**, но поддерживает несколько корней. Основные опции для "имитации" - это категории, протоколы, композиция, message forwarding.

------



**Q:** `Тип id`. Что случится во время компиляции если мы посылаем сообщение объекту `типа id`? Что случится во время выполнения если этот метод существует? Что произойдет здесь (компиляция + время выполнения): `NSString *s = [NSNumber numberWithInt:3]; int i = [s intValue];`

**A:** В `ARC` нельзя сконвертировать примитив в `id`.
Все непримитивные объекты являются типом `id`. Типу `id` можно посылать какие угодно сообщения. Объекту `NSObject` можно посылать только декларированые у него сообщения. Явное указание типа объекта помогает компилятору искать нужные методы и разрешать неоднозначности.

Выполнит соответствуюший метод, если найдёт, иначе выбросит исключение.
Выдаст предупреждение о несоответствии типов указателей, но выполняется правильно.
Переменная типа id фактически является указателем на произвольный объект. Для обозначения нулевого указателя на объект используется константа nil. При этом вместо id можно использовать и более привычное обозначение с явным указанием класса. В частности последнее позволяет компилятору осуществлять некоторую проверку поддержки сообщения объектами — если компилятор из типа переменной не может сделать вывод о поддержке объектом данного сообщения, то он выдаст предупреждение, а не ошибку.

------



**Q:** Что такое `указатель isa`? Для чего он нужен?

**A:** Каждый объект Objective-C содержит в себе атрибут isa — указатель на class object для данного объекта. class object автоматически создается компилятором и существует как один экземпляр, на который через isa ссылаются все экземпляры данного класса. Под капотом Objective-C объекты по сути C-структуры. Каждая из которых содержит поле под названием **isa**, которое является **указателем на класс**, который является экземпляром объекта. Среда выполнения следует за этим указателем, чтобы определить, какой класс является объектом, поэтому он знает, на какие селекторы отвечает объект, каков его суперкласс, какие свойства имеет объект и т.д.

------



**Q:** Что происходит с методом после того, как он не нашелся в объекте класса, которому его вызвали? 

**A:** Возбуждается исключение `NSUnknownException`.
Отправка сообщения обьекту без обработчика вызывает ошибку. Перед генерацией ошибки, runtime отправляет объекту forwardInvocation: сообщение с объектом NSInvocation в качестве единственного аргумента-объекта. NSInvocation инкапсулирует исходное сообщение и аргументы, которые были переданы с ним.

------



**Q:** Чем `категория` отличается от `расширения` (extension, наименованная категория)?

**A:** В категории объявляются дополнительные методы. В расширении добавляются методы и поля.
С помощью категорий добавляются новые методы в существующий класс. Расширения особый случай категорий, которые позволяют определить методы, которые должны быть объявлены в основном блоке реализации.

------

**Q:** Базовые модели параллелизма

**A:** 

1. Fork-join
2. Task parallelism 
3. Event loop



- Fork-join

```
master thread запускает решение задачи разбивает задачу на подзадачи
для решения каждой подзадачи создается поток
поток решает свою подзадачу и дожидается остальных
master thread собирает части решений в общее
--
Thread pool
пересоздавать потоки дорого
если подзадачи маленькие, то время создания потока >> времени выполнения задачи
в этом случае fork-join неэффективен
нужен дополнительный механизм - пул потоков
пул потоков это некий объект
подзадачи ставятся на исполнение в свободные потоки из пула 
пул потоков ведет учет свободных и занятых потоков
нет необходимости пересоздавать потоки

Managed thread pool
тот же пул потоков
но находящийся под управлением ОС
выделяет столько потоков сколько на данный момент целесообразно с точки зрения ОС (загрузка системы, количество ядер, эвристики)
так работает ThreadPool в C#
```

- Task parallelism

```
еще выше уровень абстракции
теперь управление потоками нам недоступно
есть задания в виде блоков кода, функций, либо объектов инкапсулирующих код
есть очереди в которые ставятся задания
очереди работают на управляемом системой пуле потоков
потоков создается ровно столько, сколько нужно в текущий момент времени
ресурсы выделяются оптимально GCD в iOS
```

- Event-loop

```
цикл обработки событий
поток находится в цикле ожидания событий
по приходу события поток запускает обработчик
примеры событий: срабатывание таймера, пользовательское действие с UI, приход ответа из сети на http запрос
RunLoop в iOS
```

------



**Q:** Можно ли добавить `ivar` в категорию?

**A:** Нет, но с OSX10.6 и iOS3.1 это можно обойти это с помощью ассоциативных ссылок. Это делается с помощью objc_setAssociatedObject и objc_getAssociatedObject.

```
Class c = objc_allocateClassPair([NSObject class], "Person", 0);
class_addIvar(c, "firstName", sizeof(id), log2(sizeof(id)), @encode(id));
Ivar firstNameIvar = class_getInstanceVariable(c, "firstName");
```

------



**Q:** Когда лучше использовать `категорию`, а когда `наследование`? `категория vs наследование`?

**A:** Категория используется, чтобы не плодить классы, только добавить нужный метод. Наследование используется для переопределения существующих методов.
При наследовании меняетcя поведение класса, обернув его в подкласс категория позволяет добавлять методы к существующим классам без наследования не создавая экземпляр класса, который она расширяет. Новые методы добавляются при компиляции и могут быть выполнены как обычные методы расширенного класса.

------



**Q:** Что такое `notifications (уведомления)`? Как мы должны их использовать?
Какая разница м/у использование делегатов и `notification`?

**A:** В паттерне «Наблюдатель» один объект уведомляет другие объекты об изменениях своего состояния.

`delegation` - механизм, при котором один объект взаимодействует от имени другого объекта (или в координации с ним). 
`notification` - когда состояние меняется, все объекты-наблюдатели будут уведомлены об изменении.
Они принадлежат к различным шаблонам проектирования.

------



**Q:** В чем разница между `NSArray` и `NSMutableArray`?

**A:** Первый неизменяемый, второй изменяемый.
Объект `NSMutableArray` управляет изменяемым массивом, который позволяет добавлять и удалять записи в любое время, автоматически выделяя память по мере необходимости.

------



**Q:** Чем отличается `NSSet` от `NSArray`?

**A:** `NSSet` используется для сравнения элементов не упорядочен не допускает дубликаты 
`NSArray` доступ к элементам по индексу упорядочен может содержать дубликаты

Какие операции происходят быстро в `NSSet` и какие в `NSArray?`

`NSArray`: добавление, удаление. 
`NSSet` использует `hashvalues` для поиска объекта, является неупорядоченным.
[инфа](http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html) перебор элементов быстрее с `NSArray` проверка на вхождение быстрее с `NSSet`

------



**Q:** `Формальный и неформальный (informal)` протокол? Протоколы (protocols): основные отличия между c#/java интерфейсами и Objective-C протоколами. Что делать в случае если класс не реализует какой-то метод из протокола?

**A:** `Формальный протокол (formal protocol)` обьявляет список методов (`@required` и `@optional`) которые должны быть реализованы в классе клиента.
`Неформальный протокол (informal protocol)` является категорией `NSObject`, которая неявно делает почти все объекты унаследованными от протокола. (Категория функция языка, который позволяет добавлять методы в класс без наследования ее.) Реализация методов - `@optional`. Перед вызовом метода необходимо проверить реализацию в объекте.

------



**Q:** Есть ли `приватные и защищенные` методы в Objective-C?

**A:** Да. `@public`, `@private` `@protected`. Фактически до любого свойства можно доступиться через `KVC` или `runtime` 
Все методы публичны

------



**Q:** Что такое быстрое перечисление (`fast enumeration`)?

**A:** Итерация (цикл) по коллекциям (`NSArray`, `NSDictionary`): `for Type *item in Collection {}`
это итерация по обьектам любого класса, который реализует протокол NSFastEnumeration, в том числе NSArray, NSSet и NSDictionary. Реализация протокола состоит из одного метода: `-(NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len;`

------



**Q:** Что такое `KVO`? Когда его нужно использовать? Методы для обозревания объектов? Работает ли `KVO с instance переменными (полями)` объекта?

**A:** [docs](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html) `KVO` означает наблюдение за ключевыми значениями и позволяет контроллеру или классу наблюдать за изменением значения свойства. В KVO объект может запросить уведомление о любых изменениях конкретного свойства: когда это свойство изменяет значение, наблюдатель автоматически уведомляется. Одна из реализаций паттерна **наблюдатель**. Наблюдатель **следит за конкретным** свойством объекта. Когда **значение этого свойства меняется**, наблюдателю **приходит уведомление** и он соответствующим образом реагируют.

```objective-c
addObserver:forKeyPath:options:context: //подписаться на уведомления 
observeValueForKeyPath:ofObject:change:context: //уведомить об изменении
```

В Objective-c / Swift, для назначения наблюдения, используется метод **addObserver**.

**Плюсы использования KVO**:

1. В Objective-c / Swift минимализм кода. Нет необходимости как-то изощряться, все элементы очевидны;
2. Универсальный способ общения компонентов приложения между собой;

**Минусы использования KVO**:

1. Заметное падение производительности при обильном использовании KVO. Следует очень продуманно подходить к использованию и использовать только там, где это действительно необходимо;
2. Строковые идентификаторы не проверяются компилятором на валидность. Это может привести к ошибкам при переименовании переменных;
3. Чувствительность к порядку добавления / удаления наблюдателей. Если наблюдатель пытается отписаться от наблюдаемого, на который наблюдатель в данный момент не подписан, то происходит «падение» приложения. Если же наблюдатель не отпишется до того, как наблюдаемый будет уничтожен, то произойдет утечка памяти;

------



**Q:** Что такое `KVC`? Когда его нужно использовать?

**A:** [docs](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html) `KVC` означает кодирование ключевых значений. Это механизм, с помощью которого свойства объекта можно получить с помощью строки во время выполнения, вместо того, чтобы статически знать имена свойств во время разработки. Представляет собой механизм для доступа к свойству объекта косвенно, с помощью строк для идентификации свойств, а не через вызов аксессора или доступ к ним непосредственно через переменных экземпляра. Часто используется для фильтрации в массивах (NSPredicate)

------



**Q:** Как лучше всего загрузить `UIImage c диска(с кеша)`?

**A:** В iOS присутствует функция кэширования, но прямого доступа к данным в кэше нет. Для получения доступа следует использовать класс [NSCache](https://developer.apple.com/library/prerelease/mac/documentation/Cocoa/Reference/NSCache_Class/index.html). NSCache — это объекты, которые реализуют протокол NSDiscardableContent. Класс NSCache включает в себя различные политики автоматического удаления, обеспечивающие использование не слишком большого количества памяти системы.

------



**Q:** Чем отличаются forEach и for-in?

**A:** forEach не предлагает никаких преимуществ в производительности. На самом деле, если вы посмотрите на исходный код, функция forEach на самом деле просто выполняет for-in. Для сборки релизов накладные расходы, связанные с производительностью этой функции, по сравнению с простым использованием for-in сами по себе несущественны, хотя для отладочных сборок это приводит к заметному влиянию на производительность.

Основное преимущество forEach реализуется, когда вы выполняете функциональное программирование, вы можете добавить его в цепочку функциональных вызовов, без необходимости сохранять предыдущий результат в отдельную переменную, которая понадобилась бы вам, если бы вы использовали синтаксис for-in. 

Нельзя использовать break или continue для forEach.
Return приведет к выходу только из текущего вызова, а не из внешнего диапазона, и не будет пропускать последующие вызовы.

------



**Q:** Что такое `Run Loop`?

**A:** [NSRunLoop `Циклы выполнения`](http://macbug.ru/cocoa/mthreadrunloops) - цикл обработки событий, который используются для планирования работы и координации получения входящих событий. Объект NSRunLoop также обрабатывает события NSTimer

------



**Q:** Как связаны `NSRunLoop и NSAutoreleasePool` на пальцах?

**A:** NSRunLoop запускается внутри NSAutoreleasePool который управляет памятью обьектов.

------



**Q:** Протокол [`NSCopying`](https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSCopying_Protocol/index.html), почему мы не можем просто использовать любой собственный объект в качестве ключа в словарях (NSDictionary) , что нужно сделать чтобы решить эту проблему? (разница между глубоким и поверхностным копированием)

**A:** NSCopying используется для создания копии экземпляра класса со всеми его свойствами Реализуется с помощью метода: `-(id)copyWithZone:(NSZone *)zone`

------



**Q:** Как происходит `ручное управление памятью - MRC` в iOS?

**A:** `retain/release/autorelease`

------



**Q:** `autorelease vs release`?

**A:** `release` сообщение уменьшит `retain count на 1`, если `retain count == 0`, обьект уничтожится `autorelease` сообщение добавляет обьект в текущий `NSAutoreleasePool`. 

При очистке `NSAutoreleasePool` отправит всем инстансам `-release` сообщение

------



**Q:** Что означает `ARC`?

**A:** Automatic Reference Counting

Reference Counting - is not garbare collector.

##### Как работает сборщик мусора (garbage collector)?

Когда вы хотите создать объект, но нет места в сегменте Памяти. JVM( Java Virtual Machine) проводит `Garbase Collection`, JVM `ищет в памяти все объекты, которые более не нужны и избавляется от них`. Автоматически заботиться об неиспользуемых объектах.

`Reference Counting` - `ненужный объект сразу освобождается из памяти`. Это одна из техник - Memory Management. (Управления памятью).

`Carbage Collector` - ненужный объект освобождается later (`позже`).

`Reference Counting` - `predictable (предсказуемый)`, эта техника работы с памятью `лучше чем Carbage Collector`. Carbage Collector может влиять на производительность программы когда разом проходит по всем объектом и освобождает из памяти ненужные.

##### Weak. Nonatomic. Потокобезопасность.

Weak pointer - `если объект не пометили как strong то объекту устанавливается nil` и освобождает память.

В Objective-C `не нужно использовать большой цепочки if-else для проверки на nil`.

`nonatomic` - `setter and getter` которые синтезируются у объекта is not thread-safe (`непотокобезопасны`).

`Потокобезопасность` - это когда `оба потока пытаются изменить объект`, нужно приостанавливать один поток, пока незавершился первый.

------



**Q:** Что делать, если проект написан с использованием ARC, а нужно использовать классы сторонней библиотеки написанной без ARC?

**A:** `Добавить флаг -fno-obj-arc в "Build phases->Compile Sources"`

------



**Q:** Memory Warning

**A:** Приложение никогда не вызывает этот метод напрямую. Этот метод вызывается, когда система обнаружила недостаточное количество памяти. Можно переопределить.

------



**Q:** `Atomic vs nonatomic`. Чем отличаются? Как вручную переопределить atomic/nonatomic сеттер в не ARC коде?

**A:** Многопоточный доступ — `atomic/nonatomic`( синхронизировать чтение/запись между потоками или нет)

------



**Q:** Зачем все свойства ссылающиеся на делегаты `strong/retain`. :)))

**A:** Это бред

------



**Q:** Что такое `autorelease pool`?

**A:** `Autorelease pool` - это механизм, который позволяет посылать отложенное сообщение об освобождении объекта.

------



**Q:** С подвохом: `сборщик мусора` для iPhone.

**A:** сборщика мусора в iPhone нет

------



**Q:** Нужно ли `ретейнить` (посылать сообщение retain) `делегаты`?

**A:** нет, обьект не должен являться влядельцем делегата

------



**Q:** Опишите правильный способ управленя памятью выделяемой под `Outlet'ы`?

**A:** ARC - память управляется автоматически non-ARC - нужно освобождать обьекты в dealloc

------



**Q:** Что означает [`http`](https://ru.wikipedia.org/wiki/HTTP), [`tcp`](https://ru.wikipedia.org/wiki/TCP)?

**A:** `HTTP (HyperText Transfer Protocol — «протокол передачи гипертекста»)` — протокол прикладного уровня передачи данных. `TCP (англ. Transmission Control Protocol, протокол управления передачей)` — один из основных протоколов передачи данных Интернета, предназначенный для управления передачей данных в сетях и подсетях `TCP/IP.`

------



**Q:** Какие различия между `HEAD, GET, POST`?

**A:** `GET` - Используется для запроса содержимого указанного ресурса. С помощью метода `GET` можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.

`HEAD` - Аналогичен методу `GET`, за исключением того, что в ответе сервера отсутствует тело. Запрос `HEAD` обычно применяется для извлечения [метаданных](https://ru.wikipedia.org/wiki/Метаданные), проверки наличия ресурса ([валидация](https://ru.wikipedia.org/wiki/Валидация) URL) и чтобы узнать, не изменился ли он с момента последнего обращения.

`POST` - Применяется для передачи пользовательских данных заданному ресурсу.  Аналогично с помощью метода `POST` обычно загружаются файлы на сервер.

[HTTP](https://ru.wikipedia.org/wiki/HTTP)

------



**Q:** Что такое `deadlock`?

**A:** Deadlock — ситуация в многозадачной среде или СУБД, при которой несколько процессов находятся в состоянии бесконечного ожидания ресурсов, захваченных самими этими процессами.

```objective-c
dispatch_queue_t q = dispatch_queue_create("deadlock queue", DISPATCH_QUEUE_SERIAL);
NSLog(@"1");
dispatch_async(q, ^{
    NSLog(@"2");
    dispatch_sync(q, ^{
        NSLog(@"3"); //этот код не выполнится
    });
    NSLog(@"4"); //этот код не выполнится
});
NSLog(@"5");
//Результат 1 5 2
```

------



**Q:** Что такое `livelock`?

**A:** `livelock` частая проблема в асинхронных системах. Потоки почти не блокируются на критических ресурсах. Вместо этого они выполняют свою небольшую неблокируемую задачу и отправляют её в очередь на обработку другими потоками. Может возникнуть ситуация, когда потоки друг другу начинают перекидывать какое-то событие и его обработка зацикливается. Явного бесконечного цикла, как бы, не происходит, но нагрузка на асинхронную систему резко возрастает. В результате чего эти потоки больше ничем не успевают занимаются.

------



**Q:** Что такое [`семафор (semafor)`](http://idev.by/ios/22699/)?

**A:** Семафор позволяет выполнять какой-либо участок кода одновременно только конкретному количеству потоков. В основе семафора лежит счетчик, который и определяет, можно ли выполнять участок кода текущему потоку или нет. Если счетчик больше нуля — поток выполняет код, в противном случае — нет. В GCD выглядит так: semaphore_create – создание семафора (аналог sem_init) semaphore_destroy – удаление, соответственно (аналог sem_destroy) semaphore_wait – блокирующее ожидание на семафоре (аналог sem_wait) semaphore_signal – освобождение семафора (аналог sem_post)

------



**Q:** Что такое `мьютекс (mutex)`?

**A:** [wiki](https://ru.wikipedia.org/wiki/Мьютекс), [docs](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1) Мьютексы — это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном или неотмеченном. Отличается от семафора тем, что только владеющий им поток может изменить отмеченное состояние

------



**Q:** `Асинхронность` vs `многопоточность`. Чем отличаются?

**A:** `Асинхронность` говорит о порядке исполнения кода. Если вызываемая функция не возвращает значение сразу, а отдаёт управление вызывающему коду с обещанием выдать значение позже, то эта функция асинхронная. При этом нет никаких предположений о том, как это значение будет считаться: параллельно или нет. 
`Многопоточность` говорит о том, что в физически происходит несколько потоков одновременно.

[Многопоточность](http://idev.by/ios/6599/) - каждый поток имеет свой стек и планируется на исполнение отдельно kernel’ом. Поток может общаться с другими потоками. Все потоки находятся в общем адресном пространстве приложения и делят одну и ту же виртуальную память и имеют те же права доступа что и процесс приложения.
[Асинхронность](http://pragmaticperl.com/issues/21/pragmaticperl-21-еще-немного-об-асинхронном-программировании-на-anyevent.html) Асинхронные события выполняются независимо от основного потока в неблокирующем режиме, что позволяет основному потоку программы продолжить обработку. Т/е/ результат работы функции приходит не сразу после вызова, а когда-нибудь потом.

В многопоточной реализации бывают случаи когда потоки простаивают в ожидании входных данных тем самым расходуя общие ресурсы. 

Асинхронность позволяет всегда занять процессор какими то действиями ставя все события в очередь

------



**Q:** Какие технологии в iOS возможно использовать для работы с потоками. Преимущества и недостатки.

**A:** PThread, NSOperation, GCD

------



**Q:** Чем отличается `dispatch_async от dispatch_sync`?

**A:** [docs](https://developer.apple.com/library/prerelease/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html) 
`dispatch_async` ставит копию блока на выполнение в очередь и немедненно возвращает управление 
`dispatch_sync` ставит ссылку блока на выполнение в очередь и ожидает завершения операции

------



**Q:** Для чего при разработке под iOS использовать `POSIX-потоки`? `pthread_create(&thread, NULL, startTimer, (void *)t);`

**A:** [docs](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html) NSThread - это надстройка для pthreads

------



**Q:** А чем реально `POSIX-потоки` лучше чем `GCD или NSOperationQueue вместе с NSOperation`? 

**A:** Используйте вызовы POSIX, если требуется кросс-платформенная переносимость. Если вы пишете сетевой код, который работает исключительно в OS X и iOS, вам, как правило, следует избегать сетевых POSIX-звонков, потому что с ними сложнее работать, чем с API более высокого уровня. Однако, если вы пишете сетевой код, который должен использоваться совместно с другими платформами, вы можете использовать сетевые API POSIX, так что вы можете использовать один и тот же код везде.

[read](http://blog.spec-india.com/difference-between-nsthread-and-nsoperation)

------



**Q:** Разница между свойствами `bounds и frame` объекта UIView? Понимание системы координат?

**A:** `frame` – это прямоугольник описываемый положением location(x, y) и размерами size (width, height) вьюхи относительно ее superview в которой она содержится. 
`bounds` – это прямоугольник описываемый положением location(x, y) и размерами size (width, height) вьюхи относительно ее собственной систмы координат (0, 0).

------



**Q:** Какие бывают `состояния` у приложения?

**A:** [docs](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html#//apple_ref/doc/uid/TP40007072-CH2-SW1) 

`Not Running -> Inactive -> Active -> Background -> Suspended`

`Not Running` - Приложение не запущено, либо запущенно но прервано системой.
`Inactive` - Приложение запущено на переднем плане, но в данный момент не принимает события. (Хотя может выполнять в этот момент какой-то другой код). Приложение обычно остается в этом состоянии очень ненадолго, поскольку оно сразу переходит в другое состояние.
`Active` - Приложение работает на переднем плане и принимает события. Это обычный режим для приложений на переднем плане.
`Background` - Приложение находится в фоновом режиме и выполняет код. Большинство приложений вводят это состояние ненадолго, во время перехода к состоянию suspended. Однако приложение, запрашивающее дополнительное время выполнения, может оставаться в этом состоянии еще некоторое время. Кроме того, приложение, запускаемое непосредственно в фоновом режиме, сразу входит в состояние Background, а не в состояние Inactive.
`Suspended` - Приложение находится в фоновом режиме, но не выполняет код. Система автоматически переводит приложения в это состояние и не уведомляет их об этом. Приложение приостановлено, оно остается в памяти, однако не выполняет никакого кода. При возникновении состояния с нехваткой памятью система может удалять приостановленные приложения без уведомления, чтобы освободить место для приложений переднего плана.

------



**Q:** Цикл жизни [`UIViewController`](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)?

**A:** view - lazy свойство ViewController’a. 
Инициализация view происходит в методе - loadView
Как только было обращение к .view - представление загрузится. 
Существует метод isViewLoaded -> Bool. Может иметь модальное представление. 
Знать frame .view мы можем только в методе viewWillLayoutSubviews

```
UIViewController согласно шаблону проектирования MVC обеспечивает взаимосвязь
модели и представления.

Ответсвенность:
* Управление отображением данных на вьюхе (представлении). Изменяются данные - изменяется вьюха.
* Управление пользовательскими взаимодействиями (событиями) на вьюхе (представлении). 
* Управление размерами и версткой интерфейсов вьюхи (представления).
```

Жизненный цикл:

1. init
2. loadView
3. viewDidLoad
4. viewWillAppear:
5. viewWillLayoutSubviews
6. viewDidLayoutSubviews
7. viewDidAppear:
8. viewWillDisappear:
9. viewDidDisappear: 
10. didReceiveMemoryWarning 
11. deinit (dealloc) 
12. viewWillTransition(to:with:)

------



**Q:** Что такое `View` (представление) и что такое `window`?

**A:** [docs](http://developer.apple.com/library/ios/#documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503), [read](http://www.techotopia.com/index.php/Understanding_iPhone_Views,_Windows_and_the_View_Hierarchy) window экземпляр класса UIWindow занимается отображеним видимой View иерархии. Является корневым представлением. UIView - это основной обьект для взаимодействует с пользователем. Основные задачи: 
1 Layout and subview management 
2 Drawing and animation 
3 Event handling

Может отражаться в экземпляре окна UIWindow. Представление находится в иерархии представлений ( становится Subview ) и может иметь другие представления как subview. Корень этой иерархии - окно приложения ( root window ). Представление обрабатывает события, такие как касания, так как является наследником UIResponder. Имеет в себе иерархию слоев - CALayer
CALayer — набор классов, управляющих анимацией корневого слоя объекта. Классы получают доступ к слою и применяют к нему одно из свойств. Среди таких свойств — размер и положение слоя, фоновый цвет слоя, тень, скруглённые углы и тому подобное. 
Имеет в себе 2 слоя model, presentation

------



**Q:** Какого [разрешение экранов iphon'ов](http://www.idev101.com/code/User_Interface/sizes.html), и в чем разница между `points (точками)` и `пикселями (pixels)`?

**A:** pixels (px) - точки на экране points (pt) - плотность точек на экране

------



**Q:** Что означают `IBOutlet` и `IBAction`, для чего они нужны, и что значат для препроцессора?

**A:** [read](http://nshipster.com/ibaction-iboutlet-iboutletcollection/)

```
  	#define IBAction void
  	#define IBOutlet
```

Используются для Interface Builder

------



**Q:** Как многопоточность работает с `UIKit`?

**A:** Все операции с UI должны происходить в главном потоке

------



**Q:** Как работает `UITableView`?

**A:** 



------



**Q:** Что можно сделать если клавиатура при появлении скрывает важную часть интерфейса?

**A:** 



------



**Q:** Почему мы должны `релизить IBOutlet'ты` во viewDidUnload?

**A:** 



------



**Q:** Что такое `awakeFromNeeb`, в чем разница между `xib и nib` файлами?

**A:** xib - новый формат IB(с версии 3) nib который хранится в текстовом файле, что делает его более подходящим для хранения в системах контроля версий

------



**Q:** Иерархия наследования [UIButton](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIButton_Class/).

**A:** NSObject->UIResponder->UIView->UIControl->UIButton

------



**Q:** Что такое [`Core Data`](http://habrahabr.ru/post/191334/)?

**A:** Core Data - это фрэймворк для работы с хранимыми на устройстве данными. Не смотря на то, что Core Data может хранить данные в реляционной базе данных вроде SQLite, Core Data не является СУБД (системой управления БД).
По-правде, Core Data в качестве хранилища может вообще не использовать реляционные базы данных. Core Data скорее является оболочкой для работы с данными, которая позволяет работать с сущностями и их связями (отношениями к другим объектами), атрибутами, в том виде, который напоминает работы с объектным графом в обычном объектно-ориентированном программировании.

------



**Q:** В каких случаях лучше использовать `SQLite`, а в каких `Core Data`?

**A:** В большинстве случаев Core Data хранит данные в SQLite

------



**Q:** Что такое `контекст (Managed object context)`? Как происходят `изменения в NSManagedObjectContext`?

**A:** NSManagedObjectContext - это среда в которой находится объект и которая следит за состоянием обьекта и зависимыми объектами.

------



**Q:** Что такое `Persistent store coordinator`? Зачем нужен `NSPersistentStoreCoordinator`?

**A:** NSPersistentStoreCoordinator отвечает за хранение объектов данных которые передаются из NSManagedObjectContext

------



**Q:** Какие есть нюансы при использовании `Core Data в разных потоках`? Как `синхронизировать данные между потоками`(Как синхронизировать контекст)? Синхронизация разных типов NSManagedObjectContext (получение и изменение данных в child контекстах)?

**A:** NSManagedObjectContext не thread-safe [read](http://habrahabr.ru/post/218457/) для многопоточности основная идеа - создавать для кажного потока свой NSManagedObjectContext и потом синхронизтровать

------



**Q:** Использовали ли `NSFetchedResultsController`? Почему?

**A:** NSFetchedResultsController представляет собой контроллер, предоставляемый фрэймворком Core Data для управления запросами к хранилищу. Использование NSFetchedResultsController становится актуальным для больших обьемов данных и операциями над ними. NSFetchedResultsController предоставляет механизм для обработки данных (изменения, удаления, добавления) и отображает эти изменения в таблице.

------



**Q:** Что такое [`Fault`](https://gist.github.com/krin-san/948604b5237e9a73f392f0465454719b) и зачем он нужен?

**A:** Fault является прототипом объекта, который представляет собой управляемый объект, который еще не был полностью реализован, или коллекцию объектов, которые представляют отношения: -Управляемый объект понижает экземпляр соответствующего класса, но его постоянные переменные не инициализируются. -Отношение понижения является подклассом класса коллекции, который представляет отношения.

------



**Q:** Что таке [`Fetched Property`](http://www.cimgf.com/2014/01/01/fetched-properties-useful/) и особенности работы с ним по сравнению с обычной связью?

**A:** Это свойство NSManagedObject которое хранит NSFetchRequest

------



**Q:** Что такое [`NSManagedObjectId`](http://macbug.ru/cocoa/coredatausing)? Можем ли мы сохранить его на потом если приложение закроется?

**A:** NSManagedObjectID объект является универсальным идентификатором для управляемого объекта, а также предоставляет основу для уникальности в структуре Core Data. NSManagedObjectID – универсальный потокобезопасный идентификатор. Бывает временным и постоянным. Используется в случае передачи объекта из одного контекста в другой.

------



**Q:** Какие [`типы хранилищ`](https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/Articles/cdPersistentStores.html) поддерживает CoreData?

**A:** 
XML 
SQLite 
In-Memory
Binary

------



**Q:** Что такое `ленивая загрузка (lazy loading)`? Что ее связывает с CoreData? Опишите ситуация когда она может быть полезной?

**A:** Это автоматическая подгрузка fault зависимостей lazy loading лучше для использования памяти, и быстрее, для извлечения связанных больших или редкоиспользуемых объектов

------



**Q:** Чем отличается [`UIView based Animation`](http://www.erudenko.com/2013/05/uiview.html) от [`Core Animation`](https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/CoreAnimationBasics/CoreAnimationBasics.html)?

**A:** Core Animation — фреймворк для работы с базовыми классами анимации: CABasicAnimation, CAKeyFrameAnimation, CATransition, CAAnimationGroup. Использование Core Animation полностью автоматизировано: не нужно создавать циклов и таймеров, чтобы сделать анимацию.
Выполняется мощью GPU

UIView Animation - это по факту Cocoa оболочка над CoreAnimation, но с упрощенным интерфейсом
Эти анимации на CPU

https://habr.com/ru/company/livetyping/blog/319592/

------



**Q:** [Тайминги](http://macbug.ru/cocoa/canimation04) в `CoreAnimation`?

**A:** Классы анимации и протокол CAMediaTiming предоставляют функции для управления продолжительностью анимации, темпом (как интерполированные значения распределяются по длительности), повторить ли анимацию и сколько раз, следует ли автоматически обратная когда каждый цикл завершается, и ее визуальное состояние, когда анимация завершена.

------



**Q:** Чем отличается include от import?

**A:** `import` защищен от многократного включения кода. `include` — нет.

`То есть при каждом вызове include будет происходить включение кода, даже если он уже был внедрён.`

------



**Q:** Для чего нужны методы isKindOfClass isMemberOfClass?

**A:** isKindOfClass - проверяет иерархию классов isMemberOfClass - проверяет конкретный класс

------



**Q:** Что такое `backing store`?

**A:** CALayer создает область памяти, называемую "Backing Store", растровое изображение, в котором хранится результат всех операций рендеринга.
https://gist.github.com/andrewsardone/3751168

------



**Q:** Чем отличаются `аффинные преобразования от трехмерных`?

**A:** http://macbug.ru/cocoa/canimation01

------



**Q:** Нужно ли `ретейнить (посылать сообщение retain)` делегат для `CAAnimation`?

**A:** Да, это так!! Это одно из редких исключений в управлении памятью правила.

The `delegate` object is retained by the receiver. This is a rare exception to the memory management rules described in [Advanced Memory Management Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i).

An instance of `CAAnimation` should not be set as a delegate of itself. Doing so (outside of a garbage-collected environment) will cause retain cycles.

------



**Q:** Чем отличаются замыкания в Swift и блоки в Objective-C?

**A:** Замыкание Swift и блоки Objective-C совместимы, поэтому вы можете передать замыкание Swift в методы Objective-C, которые ожидают блоков. Замыкания  и функции Swift имеют один и тот же тип, поэтому вы даже можете передать имя функции Swift.

Семантика замыкания похожа на семантику захвата блоков, но отличается одним ключевым способом: Переменные изменяются, а не копируются. Другими словами, поведение __блока в Objective-C является поведением по умолчанию для переменных в Swift

------



**Q:** Слои архитектуры iOS?

**A:** `iPhone Hardware -> Core OS -> Core Services -> Media -> Cocoa Touch`
`Core OS` - System, Accelerate Framework, Core Bluetooth Framework, Local Authentication Framework, Security Framework, File system, Keychain access
`Core Services` - Core Location, Net Service, File Accesses, SQLite, Networking, Threading
`Media` - Core Audio, Core Animation, Video playback...
`Cocoa touch` - Multi-Touch, ImagePickers, Camera, Core Motion, Web View, Map Kit, Controls

```
Core OS (OSXKernel, Mach etc)
Core Services (Foundation, Networking etc)
Media (Core Audio, OpenAL, Quartz, Core Animation etc)
Cocoa Touch (UIKit, Camera, Controls, MapKit etc)
```

##### Core OS:

`Все что связано с ОС Unix`.

(OSXKernel, Mach 3.0, BSD, Sockets, Security, Power Management, Keychain Access, Certificates, File System, Bonjour).

OSXKernel, BSD, Mach - Unix operating system on device.

Эти API на С.

##### Core Service:

```
Foundation и сервисы.
```

(Collections, Address Book, Networking, File Access, SQLite, Core Location, Net Services, Threading, Preferences, URL Utilities).

##### Media:

```
Аудио, Видео и Графика
```

(Core Audio, OpenAL, Audio Recording, Video Playback, Quartz (2D), Core Animation, OpenGL ES, PDF)

##### Cocoa Touch:

```
Все что связано с UI.
```

UIKit, Multi-Touch, Core Motion, View Hierarchy, Localization, Controls, Alerts, Web View, Map Kit, Image Picker, Camera

##### Внешние компоненты iOS платформы?

```
Tools (Xcode, Debugger, Source Control, Static Analyzer).
Language (Objective-C)
Frameworks (CoreData, UIKit, Foundation etc.)
Design Patterns (MVC)

Tools:
---

`Xcode` - Debugger, UI building, Source code editing and control.

`Instruments` - Profiling, Memory Usage.

Language:
---

`Objective-C`

`Swift`

`C`

Frameworks:
---

Foundation, UIKit, Core Motion, Core Data, Map Kit etc.

Design Strategies:
---

MVC.
```

------



**Q:** Как настроить Live Rendering?

**A:** Атрибут [@IBDesignable](http://twitter.com/IBDesignable) позволяет Interface Builder обновлять конкретные элементы.

------



**Q:** Чем отличаются синхронная и асинхронная задача?

**A:** Синхронная: ждет, пока задача завершится. Асинхронная: завершает задачу в фоновом режиме и уведомляет вас о завершении.

------



**Q:** Что такое b-деревья?

**A:** Это [поисковые деревья](https://ru.wikipedia.org/wiki/B-дерево), которые предоставляют упорядоченное хранилище ключевых значений с отличными характеристиками производительности. Каждый узел хранит отсортированный массив своих собственных элементов и другой массив для своих дочерних элементов.

------



**Q:** Что такое объект NSError?

**A:** Существует три части объекта NSError: домен, код ошибки и словарь с пользовательской информацией. Домен — это строка, которая идентифицирует, к какой категории относится эта ошибка.

------



**Q:** Что такое Enum?

**A:** Enum – это тип, который в основном содержит группу связанных значений.

------



**Q:** Почему мы не используем strong для enum в Objective-C?

**A:** Поскольку enum не являются объектами, мы не указываем здесь strong или weak.

------



**Q:** Что такое @synthesize в Objective-C?

**A:** Synthesize генерирует методы getter и setter для вашего свойства.

------



**Q:** Что такое @dynamic в Objective-C?

**A:** Мы используем dynamic для подклассов NSManagedObject. @dynamic сообщает компилятору, что геттер и сеттеры реализованы где-то в другом месте.

------



**Q:** Почему мы используем synchronized?

**A:** Synchronized гарантирует, что только один поток может выполнять этот код в блоке в любой момент времени.

------



**Q:** В чем разница strong, weak, read only и copy?

**A:** Атрибуты свойства `strong`, `weak`, `assign` определяют, как будет управляться память для этого свойства.

`Strong` означает, что в сгенерированном сеттере счетчик ссылок на присваиваемый объект будет увеличен и ссылка на него будет поддерживаться в течение жизни объекта.

`Weak` означает, что мы указываем на объект, но не увеличиваем счетчик ссылок. Он часто используется при создании родительских-дочерних отношений. Родитель имеет сильную ссылку на ребенка, но ребенок имеет только слабую ссылку на родителя.

`Read only` —  мы можем установить свойство изначально, но затем его нельзя будет изменить.

`Copy` означает, что мы копируем значение объекта при его создании. Также предотвращает изменение его значения.

------



**Q:** Что такое Dynamic Dispatch?

**A:** Dynamic Dispatch — это процесс выбора реализации полиморфной операции, которая является методом или функцией для вызова во время выполнения. Это происходит, когда мы хотим вызывать наши методы как метод объекта. Swift по умолчанию не выполняет Dynamic Dispatch.

------



**Q:** Что такое обработчик завершения?

**A:** Обработчики завершения очень удобны, когда наше приложение вызывает API, и нам нужно что-то сделать, когда эта задача будет выполнена: например, обновить пользовательский интерфейс, чтобы отобразить данные из вызова API. Обработчики завершения можно найти в API Apple, например, dataTaskWithRequest, и они могут быть очень полезными в вашем коде.
Обработчик завершения принимает код с тремя аргументами: (NSData?, NSURLResponse?, NSError?), который ничего не возвращает: void. Это означает завершение.
Обработчики завершения должны быть помечены @escaping, так как они выполняются после выполнения функции.

------



**Q:** Что такое Responder Chain?

**A:** Responder Chain — это иерархия объектов, которые могут ответить на полученные события.
Для обработки взаимодействия пользователя с UI и внешних событий в iOS используется механизм Responder Chain
Для touch-событий:

- Объект типа `UIWindows` пытается передать touch в объект типа `UIView`, в котором он был вызван (hit-testing)
- Если `UIView` не может обработать данный touch (например, объект в данный момент невидим, или отключил возможность взаимодействия с собой), touch передается в superview данного компонента, и так далее вверх, пока он не будет обработан

Класс `UIApplication`, `UIViewController` и `UIView` наследуются от класса `UIResponder`.
Класс `UIResponder` определяет порядок, в котором объекты обрабатывают события (touch-события, события от элементов UI (кнопки и т.д.), изменение текста). Кроме того, `UIResponder` объявляет методы, которые позволяют объектам определять, кто первым будет отвечать и обрабатывать сообщения:

- `becomeFirstResponder` — объект-получатель сообщения будет первым получать все события, посылаемые системой
- `resignFirstResponder` — объект-получатель отказывается от обработки сообщений первым

------



**Q:** Что такое ABI?

**A:** [ABI (двоичные интерфейсы приложения)](https://ru.wikipedia.org/wiki/Двоичный_интерфейс_приложений) важны, когда речь идет о приложениях, которые используют внешние библиотеки. Если программа создана для использования определенной библиотеки, и эта библиотека будет позже обновлена, то вам надо будет перекомпилировать это приложение (а с точки зрения конечного пользователя у вас вообще может не быть исходника). Если обновленная библиотека использует один и тот же ABI, то ваша программа не будет нуждаться в изменении.

------



**Q:** Почему шаблон проектирования очень важен?

**A:** Шаблоны проектирования — это повторно используемые решения для распространенных проблем в создании приложений. Эти шаблоны созданы, чтобы помочь вам писать простой код, который можно будет использовать снова и снова.

------



**Q:** Сколько различных аннотаций доступно в Objective-C?

**A:** 

- _Null_unspecified – мосты в Swift для неявно-развернутых optional. Это по умолчанию.
- nonnull: значение не будет равно нулю; мосты к регулярной ссылке.
- nullable: значение может быть nil; мосты к optional.
- null_resettable: при чтении значение никогда не будет равным нулю, но вы можете установить его обнулить. Применяется только к свойствам.

------



**Q:** Каково главное преимущество Swift?

**A:** 

- опциональные типы, которые предохраняют приложения от сбоев;
- встроенное исправление ошибок;
- замыкающие выражения;
- Swift более быстрый в сравнении с другими языками;
- типобезопасный язык;
- поддержка сопоставления с образцом.

------



**Q:** Объясните lazy в Swift?

**A:** Начальное значение ленивых свойств вычисляется только тогда, когда свойство вызывается в первый раз. Бывают ситуации, когда ленивые свойства оказываются очень удобны разработчикам.

------



**Q:** Что такое defer?

**A:** `defer` — это ключевое свойство, которое обеспечивает выполнение блока кода, когда остальная текущая область не выполняется.

------



**Q:** Как передать переменную в качестве ссылки?

**A:** Следует упомянуть, что существуют два типа переменных: ссылочные и типы значений. Разница между этими двумя типами заключается в том, что, передавая тип значения, переменная создаст копию своих данных, а переменная ссылочного типа будет просто указывать на исходные данные в памяти.

------



**Q:** Почему лучше использовать функции высшего порядка?

**A:** Функции высшего порядка — это функции, которые берут другую функцию в качестве параметра или возвращают функцию как результат. Swift определяет эти функции как CollectionType.
Самой базовой функцией высшего порядка является filter.

------



**Q:** Что такое параллелизм?

**A:** Параллелизм разделяет пути выполнения вашей программы, чтобы они могли работать одновременно. Основные термины:

- Процесс — экземпляр исполняемого приложения; (Процесс - это контейнер для потоков)
- Поток — путь выполнения для кода; (Поток - базовая абстракция параллельных вычислений)
- Многопоточность — несколько потоков или несколько путей выполнения, выполняемых в одно и то же время.
- Параллелизм — выполнение нескольких задач одновременно масштабируемым образом.
- Очереди — это легкие структуры данных, которые управляют объектами в порядке First-in, First-out (FIFO).
- Синхронные и асинхронные задачи.

------



**Q:** Что такое Grand Central Dispatch (GCD)?

**A:** GCD — это библиотека, которая предоставляет низкоуровневый и объектный API для одновременного запуска задач при управлении потоками за кулисами. Терминология:

- Очереди отправки. Очередь отправки отвечает за выполнение задачи в порядке FIFO.
- Серийная очередь отправки. Последовательная очередь отправки запускает задачи по одной.
- Параллельная очередь отправки. В параллельной очереди отправки выполняется столько задач, сколько возможно без ожидания завершения начатых задач.
- Основная очередь отправки. Глобально доступная последовательная очередь, которая выполняет задачи в основном потоке приложения.

------



**Q:** Читатели-писатели?

**A:** Одновременное чтение нескольких потоков, когда должна происходить запись одного потока. Решением проблемы является блокировка чтения-записи, которая позволяет одновременный доступ только для чтения и отдельный доступ для записи. Терминология:

- Состояние гонки возникает, когда два или более потока могут обращаться к общим данным, и они пытаются изменить его одновременно.
- Тупик возникает, когда две или несколько задач ждут завершения других, но этого не происходит.
- Проблема читателей-писателей: одновременное чтение нескольких потоков, в то время как должна происходить запись одного потока.
- Блокировка чтения-записи: такая блокировка позволяет одновременный доступ к общему ресурсу только для чтения, в то время как операции записи должны запрашивать эксклюзивный доступ.
- Блок барьера отправки создает узкое место по типу серии при работе с параллельными очередями.

------



**Q:** NSOperation — NSOperationQueue — NSBlockOperation?

**A:** `NSOperation` добавляет немного дополнительных расходов по сравнению с GCD, но при его использовании мы можем добавить зависимость между различными операциями и повторное использование, отменить или приостановить их.

`NSOperationQueue` позволяет создавать пул потоков и использовать его для параллельного выполнения NSOperations. Операционные очереди не являются частью GCD.

`NSBlockOperation` позволяет создавать NSOperation из одного или нескольких замыкающих выражений. NSBlockOperations может иметь несколько блоков, которые выполняются одновременно.

------



**Q:** Объясните метод Swizzling в Swift

**A:** Иногда для удобства, иногда для того, чтобы обойти баг в фрэймворке, а иногда просто от безысходности, может понадобиться переопределить поведение некоторого метода класса, созданного кем-то другим. Метод Swizzling позволяет подменить метод вашим прямо в runtime, притом оставляя оригинальную имплементацию доступной.
Метод Swizzling является хорошо известной практикой в Objective-C и других языках, поддерживающих динамическую диспетчеризацию методов.
Посредством Swizzling реализация метода может быть заменена на другую во время выполнения, путем изменения отображения между определенным #selector(method) и функцией, содержащей его реализацию.
Для использования метода swizzling с классами Swift есть два требования, которые необходимо соблюдать:
он должен быть наследником NSObject
подменяемый метод должен иметь атрибут dynamic

------



**Q:** Что такое сбегающее замыкание?

**A:** Когда говорят, что замыкание сбегает из функции, то это значит, что это замыкание было передано в функцию в качестве аргумента и вызывается уже после того, как функция вернула значение.
Если замыкание хранится в переменной, которая была объявлена вне функции, а затем эта переменная была передана в качестве аргумента в функцию, то получается, что замыкание, которое посредством переменной передается в функцию, сбегающее. В качестве примера можно рассмотреть функции, которые выполняют асинхронные операции в завершающем обработчике, который является замыканием. То есть получается, что функция завершает свою работу, после чего вызывается завершающий обработчик. Или другими словами обработчик не вызывается, пока не завершится работа функции, таким образом получается, что данному замыканию нужно сбежать из области работы функции, чтобы отработать позже.

------



**Q:** Объясните  [weak self] и [unowned self] ?

**A:** unowned ( не сильная ссылка ) делает то же самое, что и слабая, за одним исключением: 
Переменная не станет нулевой и не должна быть опциональной.
Когда вы пытаетесь получить доступ к переменной после того, как ее экземпляр был освобожден. Это означает, что вы должны использовать unowned только тогда, когда уверены, что эта переменная никогда не будет доступна после того, как соответствующий экземпляр будет освобожден.
Однако, если вы не хотите, чтобы переменная была слабой И вы уверены, что к ней нельзя будет получить доступ после того, как соответствующий экземпляр будет освобожден, вы можете использовать unowned.
Каждый раз, когда используется с неопциональными типами
Каждый раз, когда используется с let
Объявив [weak self], вы можете справиться со случаем, что в какой-то момент он может быть нулевым внутри замыкания, и поэтому переменная должна быть необязательной. Случай использования [weak self] в асинхронном сетевом запросе, находится в контроллере представления, где этот запрос используется для заполнения представления.
"Когда ты создаёшь weak для объекта, аллоцируется  side table
Когда умирает объект, если на него есть где то weak ссылка, адрес в памяти все ещё за этим объектом, только вместо данных там зомби обжект(мусор обыкновенный)
Т.е. если у тебя есть weak ссылка на объект и он где то умер, сама по себе ссылка weak не становится nil 
Она обращается в sideTable, понимаешь что там мусор и возвращает nil
Если ссылок больше нет, то тут происходит высвобождение адреса
Таблица аллоцируется если weak ссылка на объект
Либо переполнился счётчик strong/unowned ссылок
Когда у тебя выполняется кложур у которого в capture list есть weak self - это значит что мы знаем указатель на side table self’a
В нем есть все необходимое чтобы мы смогли получить объект, но счетчики сильных ссылок там 0, и autoreleasepoll выполнил drain
Теперь там по указателю на инстанс лежит остатки от объекта(мусор), с помощью weak обращения мы безопасно чекаем этот мусор, и если там мусор, weak вернёт nil
И, в случае, если там все ссылки равны нулю после итерации кложура, объект полностью деалоцируется из памяти"

------



**Q:** Что такое NSFetchRequest ?

**A:** `NSFetchRequest` - это класс, отвечающий за получение данных из Core Data. Запросы Fetch являются мощными и гибкими. Вы можете использовать запросы на выборку для получения набора объектов, удовлетворяющих заданным критериям, индивидуальных значений и многого другого.

------



**Q:** Объясните ключевое слово `final` в классе?

**A:** Добавляя ключевое слово `final` перед именем метода, мы предотвращаем его переопределение. Если мы сможем заменить `final` на `static`, то получим такое же поведение.

------



**Q:** В чем разница между open и public уровнями доступа?

**A:** `open` позволяет другим модулям использовать класс и наследовать его; для членов он позволяет другим модулям использовать член и переопределять его
`public` позволяет другим модулям использовать только открытые классы и открытые члены. Публичные классы больше не могут быть подразделены на подклассы, а публичные члены не могут быть переопределены.

------



**Q:** Какая разница между fileprivate, private и public private(set) уровнями доступа ?

**A:** `fileprivate` доступен внутри текущего файла, `private` доступен внутри текущей декларации.
`public private(set)` означает, что геттер является публичным, но геттер - приватным.

------



**Q:** Что такое SOLID?

**A:** 

**S — Single responsibility principle** — Принцип единственной обязанности:
На каждый класс должна быть возложена одна-единственная обязанность.

**O — Open/closed principle** — Принцип открытости/закрытости:
Программные сущности должны быть открыты для расширения, но закрыты для изменения.

**L — Liskov substitution principle** — Принцип подстановки Барбары Лисков:
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

**I — Interface segregation principle** — Принцип разделения интерфейса
Много специализированных интерфейсов лучше, чем один универсальный.

**D — Dependency inversion principle** — Принцип инверсии зависимостей:
Зависимости внутри системы строятся на основе абстракций. Модули верхнего уровня не зависят от модулей нижнего уровня. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Сокращение от английского **Single responsibility**, **Open-closed**, **Liskov substitution**, **Interface segregation** и **Dependency inversion**) — акроним, введённый Майклом Фэзерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали пять основных принципов ООП и проектирования.

- **single responsibility — принцип единственной ответственности;**
- **open-closed — принцип открытости / закрытости;**
- **liskov substitution — принцип подстановки Барбары Лисков;**
- ***\*Interface segregation — принцип разделения интерфейса;\****
- **Dependency inversion — принцип инверсии зависимостей;**

------

**Single responsibility**

*Принцип единственной ответственности.*

Каждый класс должен иметь одну и только одну причину для изменений.

------

**Open-closed**

*Принцип открытости / закрытости.*

«Программные сущности … должны быть открыты для расширения, но закрыты для модификации.».

------

**Liskov substitution**

*Принцип подстановки Барбары Лисков.*

«Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.» См. также контрактное программирование. Наследующий класс должен дополнять, а не изменять базовый.

------

**Interface segregation**

*Принцип разделения интерфейса.*

«Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.»

------

**Dependency inversion**

*Принцип инверсии зависимостей.*

«Зависимость на Абстракциях. Нет зависимости на что-то конкретное.»

[Шпаргалка]: http://sergeyteplyakov.blogspot.com/2014/10/solid.html	"Шпаргалка"

------



**Q:** Что такое  RGR ( Red — Green — Refactor)?

**A:** Красный, зеленый и рефрактор являются стадиями TDD (Test Driven Development).
Красный: Напишите небольшое количество тестового кода, как правило, не более семи строк и посмотрите, как он выйдет из строя.
Зеленый: Напишите небольшое количество кода. Опять же, обычно не более семи строк кода и сделайте так, чтобы ваш тест прошел.
Рефактор: Тесты проходят, вы можете вносить изменения, не беспокоясь. Очистите свой код.
https://gist.github.com/orkoden/201f811570582fab2b5b

------



**Q:** Где мы используем инъекцию зависимостей?

**A:** Мы используем storyboard или xib в нашем приложении для iOS, а затем создали IBOutlets. IBOutlet - это свойство, связанное с видом. Они вводятся в контроллер представления, когда оно инстанцируется, что, по сути, является формой инъекции зависимостей.
Существуют формы инъекции зависимости: инъекция конструктора, инъекция свойства и инъекция метода.

------



**Q:** Какие функции высшего порядка мы можем использовать на типах коллекций?

**A:** `map(:):` Возвращает массив результатов после преобразования каждого элемента в последовательности, используя предусмотренное замыкание.
`filter(:):` Возвращает массив элементов, удовлетворяющих предикату предоставленного замыкания.
`reduce(_:_:):` Возвращает единственное значение, комбинируя каждый элемент в последовательности с использованием предоставленного замыкания.
`sorted(by:):` Возвращает массив элементов в последовательности, отсортированный по предикату предоставленного замыкания.

Swift дает нам методы `map(),` `compactMap()` и `flatMap()`, но хотя они могут звучать одинаково, они делают очень разные вещи.
`map()` вытащит значение из своего контейнера, преобразует его с помощью указанного вами кода, а затем поместит обратно в свой контейнер. `compactMap()` делает то же самое, но если ваше преобразование вернёт `optional`, то оно будет разворачиваться, и любые nil-значения будут отброшены.
Optional - опциональные опции глубоко запутаны в работе, но именно здесь приходит flatMap(): она также выполняет преобразование ("map" часть своего имени), но затем сглаживает то, что возвращается, так что " optional optional" просто становится " optional".

То есть, либо всё это существует, либо ничего не существует - она сглаживает двойные опционалы вплоть до одиночных. В конце концов, нас не волнует, существует ли внешняя или внутренняя опция, а только то, есть есть ли там внутри значение или нет, вот почему функция `flatMap()` так полезна.

------



**Q:** Какая разница между ANY и ANYOBJECT?

**A:** Согласно документации Apple's Swift:
`Any` может представлять экземпляр любого типа, включая типы функций и дополнительные типы.
`AnyObject` может представлять экземпляр любого типа класса.
https://medium.com/@mimicatcodes/any-vs-anyobject-in-swift-3-b1a8d3a02e00

------



**Q:** Объясните разницу SOAP и REST?

**A:** Оба они помогают нам получить доступ к веб-сервисам.
`SOAP` полагается исключительно на XML для предоставления услуг обмена сообщениями. SOAP, безусловно, тяжелый выбор для доступа к веб-службам. Первоначально разработанный Microsoft.
`REST (Representational State Transfer)` обеспечивает более легкую альтернативу. Вместо того, чтобы использовать XML для выполнения запроса, REST во многих случаях полагается на простой URL. REST может использовать четыре различных HTTP глагола (GET, POST, PUT и DELETE) для выполнения задач.

------



**Q:** Сколько различных способов передачи данных в Swift ?

**A:** Существует множество различных способов, таких как Delegate, KVO, Segue и NSNotification, Target-Action, Callbacks.

------



**Q:** Поясните AutoLayout

**A:** AutoLayout обеспечивает гибкую и мощную систему компоновки, которая описывает, как представления и элементы управления пользовательским интерфейсом вычисляют размер и положение в иерархии.

Система уравнений.

------



**Q:** Что такое блоки в Obj-C

**A:** `Блоки` — это фичи языка, которые позволяют создавать отдельные сегменты кода и могут передаваться методам или функциям, как если бы они были значениями.

Блоки — это **объекты** **Objective-C**. И как объекты, блоки имеют тип. Но блоки так же возвращают значения, а значит ведут себя как функции.

- Являются объектами
- Существуют трех видов
- По-умолчанию создаются на стеке (при MRC)

Три вида блоков:

`Глобальные блоки (Global blocks)`  – блоки, не захватывающие никакого состояния (переменных). Располагаются в глобальной памяти (не в стеке, не в куче).

`Блоки в стеке (Stack blocks)` – когда мы создаем блок, который захватывает внешние переменные, блок размещается в стеке. С обычными объектами Objective-C так поступать не разрешает, но с блоками можно. Причина, по которой блоки поместили в стек по умолчанию, — это скорость. В общем случае, когда время жизни блока меньше, чем у функции стека, содержащей его, это очень хорошая оптимизация.

`Блоки в куче (Malloc blocks)` – После копирования блока из стека в кучу, блок может использоваться за пределами области действия в которой он был определен. Так же, после копирования, блок становится объектом к которому применяется подсчет ссылок. Мы должны указать `copy` в качестве атрибута свойства, потому что необходимо скопировать блок, чтобы отслеживать его захваченное состояние за пределами исходной области видимости. Это не то, о чем нужно беспокоиться при использовании ARC, так как это произойдет автоматически, но лучше всего, чтобы атрибут свойства отображал результирующее поведение.

`Блок захватывает контекст, в котором определен`. Он создает внутри себя константные локальные переменные и указатели того, что захватывает. Что при использовании объектов увеличит счетчик ссылок, по обычной для ARC логике (при копировании блока в кучу).

Однако при использовании **__block** счетчик ссылок не увеличится и переменные можно будет модифицировать.
Блок имеет свой тип, который можно описать структурой: возвращаемый_тип (^имя_блока)(параметры)

Поскольку блоки являются объектами Objective-C, нет ничего удивительного в том, что методы классов могут возвращать объекты типа блок.

В блоках могут возникать **retain Cycle.**

**Блоки в стеке** **(Stack blocks)**

##### Когда нужен weak refence для self внутри блока?

Если блок находится во владении класса (retained). Например объект хранит свойство - блок.

Объект который владеет блоком - в этом случае и происходит захват `self` - внутри блока и происходит `retain cycle (цикла владения)`.

Where you get into trouble is something like:

```
//In the interface:
@property (strong) void(^myBlock)(id obj, NSUInteger idx, BOOL *stop);

//In the implementation:
[self setMyBlock:^(id obj, NSUInteger idx, BOOL *stop) {
  [self doSomethingWithObj:obj];     
}];

The block retains self, but self doesn't retain the block. If one or the other is released, no cycle is created and everything gets deallocated as it should.

​```objc
__weak MyObject *weakSelf = self;
[[SomeOtherObject alloc] initWithCompletion:^{
   MyObject *strongSelf = weakSelf;
  [strongSelf doSomething];
}];
```

__weak typeof(self) weakSelf = self;

В `инструментах` можно отследить - `Record reference counts`

retain cycle - strong reference cycle.

```
The correct solution is this:
__weak typeof(self) weakSelf = self;
dispatch_async(dispatch_get_main_queue(), ^{
    typeof(self) strongSelf = weakSelf;
    if (strongSelf) {
        [strongSelf doSomething];
    } else {
        [someOtherObject doSomethingElse];
    }
});
```

##### Пример retain cycle в блоке?

Self-объект хранит (владеет) блок. Блок удерживает self объект.

You don’t need to make two sets of weak references. What you want to avoid with blocks is a retain cycle—two objects keeping each other alive unnecessarily. If I have an object with this property:

```
@property (strong) void(^completionBlock)(void);
```

and I have this method:

```
- (void)doSomething
{
    self.completionBlock = ^{
        [self cleanUp];
    };

    [self doLongRunningTask];
}
```

the block will be kept alive when I store it in the `completionBlock` property. But since it references `self` inside the block, the block will keep self alive until it goes away—but this won’t happen since they’re both referencing each other.

------



**Q:** Каковы самые большие изменения в UserNotifications ?

**A:** Мы можем добавить аудио, видео и изображения.
Мы можем создать пользовательские интерфейсы для уведомлений.
Мы можем управлять уведомлениями с помощью интерфейсов в центре уведомлений.
Новые расширения Notification позволяют нам управлять удаленными уведомлениями до того, как они будут доставлены.

------



**Q:** Объяснить разницу между `atomic` и `nonatomic` synthesized  свойствами

**A:** `atomic` : Это поведение по умолчанию. Если объект объявлен атомарным, то он становится потокобезопасным. Потокобезопасность означает, что только один поток конкретного экземпляра этого класса может иметь контроль над этим объектом.
`nonatomic`: Не является потокобезопасным. Мы можем использовать неатомарный атрибут свойства, чтобы указать, что синтезированные атрибуты доступа просто устанавливают или возвращают значение напрямую, без каких-либо гарантий того, что произойдет, если одно и то же значение будет одновременно доступно из разных потоков. По этой причине, доступ к неатомному свойству быстрее, чем к атомарному.

------



**Q:** Что такое ARC и чем он отличается от AutoRelease?

**A:** AutoRelease все еще используется ARC. ARC используется внутри области видимости, авторелиз используется вне области видимости функции.

------



**Q:** Какова связь между iVar и @property?

**A:** `iVar` - переменная экземпляра. Она не может быть доступна, если мы не создадим доступы, которые генерируются `@property`. iVar и его контрагент @property могут иметь разные имена.
Доступ к iVar всегда возможен с помощью KVC.

------





**Q:** Что такое Протокол?

**A:** Протокол определяет план методов, свойств и других требований, которые подходят для конкретной задачи или части функциональности. Затем протокол может быть принят классом, структурой или перечислением, чтобы обеспечить фактическую реализацию этих требований.

------



**Q:** Объясните общую функцию zip(_:_:)

**A:** В соответствии с Swift документацией, zip создает последовательность пар, построенных из двух опорных. Это означает, что мы можем создать словарь, включающий два массива.

------



**Q:** Что такое URLSession?

**A:** Когда мы хотим получить содержимое с определенного URL, мы выбираем URLConnection. Существует три типа задач:
Data tasks: получение данных в память
Download tasks: загрузка файла на диск
Upload tasks: загрузка файла с диска и получение ответа в виде данных в памяти

------



**Q:** В чем разница между WKWebView and UIWebView?

**A:** WKWebView имеет собственное хранилище куки-файлов и не разделяет его на все приложение и все другие веб-просмотры, как в случае с (UIWebView).

------



**Q:** Объяснить смысл @objc

**A:** Мы можем пометить декларацию Swift с помощью @objc, чтобы указать, что она должна быть доступна для Objective-C. В Swift 3 многие декларации автоматически выводились как доступные для Objective-C. Самое распространенное место для этого - любой метод Swift, к которому мы хотим обратиться с помощью селектора.

------



**Q:** Что означает ключевое слово `mutating`?

**A:** Ключевое слово `mutating` используется для того, чтобы позволить изменять переменные в структуре или перечислении. Если нам нужно изменить свойства типа значения, мы должны использовать мутирующее ключевое слово в методе instance.

------



**Q:** Разница в Stack и Heap ?

**A:** Наш код занимает некоторое место в iOS. Размер этого места иногда фиксируется, а иногда может меняться в зависимости от того, что пользователь будет вводить во время работы программы. В принципе, из-за этой разницы у нас есть два разных метода: Стек и куча
Стек используется и автоматически удаляется из памяти после завершения работы. Но в Heap пользователь может сделать это, написав ручной код для удаления из памяти.

`Стек`:
Стек прост в использовании.
Он хранится в оперативной памяти компьютера.
Созданные переменные автоматически удаляются при выходе из стека.
Это довольно быстро по сравнению с Heap.
Созданные переменные можно использовать без указателя.
`Куча`:
По сравнению со стеком, довольно медленная.
При некорректном использовании создает проблемы с памятью.
Переменные используются с указателями.
Создаются во время выполнения.

------



**Q:** UIBezierPath?

**A:** Класс UIBezierPath позволяет нам определить пользовательские пути, которые описывают любую форму, и использовать эти пути для достижения любого пользовательского результата.

------



**Q:** CAShapeLayer?

**A:** CAShapeLayer является подклассом CALayer, он обеспечивает аппаратное ускорение рисования всех видов 2D-форм и включает в себя дополнительные функциональные возможности, такие как цвета заливки и обводки, накладки на линии, узоры и многое другое.

------



**Q:** Поясните Encoding, Decoding и Serialization, Deserialization

**A:** `Сериализация` - это процесс преобразования данных в одну строку или json, чтобы их можно было легко хранить или передавать. `Сериализация`, также известная как кодирование. `Обратный процесс` преобразования одной строки в данные называется `декодированием, или десериализацией`. В скором времени мы используем протокол `Codable`, которому тип может соответствовать, чтобы объявить, что он может быть закодирован и декодирован. По сути, это псевдоним для протоколов `Encodable` и `Decodable`.

------



**Q:** Различия Generics и AnyObject?

**A:** Дженерики безопасны для типов, т.е. если вы передадите строку как общую и попытаетесь использовать ее как целое число, компилятор пожалуется, и вы не сможете скомпилировать свою. Потому что Swift использует статический набор текста и может выдать ошибку компилятора.
Если Вы используете AnyObject, компилятор понятия не имеет, можно ли рассматривать объект как строку или как целое число. Это позволит вам делать с ним все, что угодно.

------



**Q:** Как происходит обработка `memory warning`(предупреждение о малом количестве памяти)? Зависит ли обработка от версии iOS, как мы должны их обрабатывать?

**A:** 



------



**Q:** Когда нужно использовать метод `retainCount` (никогда, почему?) Объясните что такое `подсчет ссылок (retain count`)?

**A:** Количество хранимых данных - это способ управления памятью в программе Objective-C.
Когда вы создаете объект, счетчик ссылок имеет значение 1. Когда вы посылаете
объект сообщение об удержании, счетчик его ссылок увеличивается на 1. Когда вы
посылаете объекту сообщение об освобождении, счетчик его ссылок уменьшается на 1. 
Когда вы отправляете объекту сообщение об освобождении, счетчик ссылок уменьшается на 1. 
уменьшается на 1 на каком-то этапе в будущем.  Если у объекта счет ссылок 
снижается до нуля, он освобождается. 

------



**Q:** Как организована память?

**A:** Песочница - это виртуальное адресное пространство
Представляет собой 32x - 4 GB, 64x - 256 TB блок адресов
Программа - это тоже процесс
Mapping виртуального адреса в физическую память
Существует page table, которая описывает соответствие физической памяти
Kernel space - область виртуального адресного пространства, резерверуемая под ядро 
Доступ к kernel space есть только у привилегированного кода
Stack (Стэк) - автоматические переменные, передача аргументов функций и адресов возврата. Скалярные типы данных
Heap (Куча) - динамические переменные. Объектные типы данных. Под динамические переменные (которые с указателями).
BSS - неинициализированные статические и глобальные переменные
Data - константы, глобальные неинициализированные переменные

Для `объектов objc` память выделяется `в куче (heap)`. Для работы с управлением памятью объектов используются методы: `retain, release и autorelease`. Память кучи может быть `занятой` и `свободной` если объект обнулить.

Для `примитивов` память выделяется `на стеке`.

Для `блоков` память выделяется `на стеке`. Но можно удержать блок (в куче) `посылкой сообщения copy`.

------



**Q:** Управление памятью

**A:** Ручное (Allocators, GNU malloc), Автоматическое (Garbage collector), Полу-автоматическое (Reference counting, Memory pools)

Reference counting:
`Manual Retain Release (MRR)` - Если вы посылаете alloc, new, copy, или retain объекту, вы должны компенсировать это, используя release или autorelease
Если вы получили объект другим путем, и вам необходимо, чтоб объект был “живым” достаточно долгое время, вы должны использовать retain, copy или autorelease. Естественно, позже это должно быть компенсировано вами
Не все объекты подчиняются этим правилам, а именно: объекты созданные литеральным способом 
NSString, NSNumber, NSArray etc.
Существует конвенция, которая гласит, что все порождающие методы, которые не посылают объекту alloc, copy, new должны добавлять этот объект в autorelease pool.

`Automatic Reference Counting (ARC)` - Доступна с iOS 4 и Mac OS X 10.6
Тоже самое, что и MRR, но за нас это делает в момент компиляции приложения. NSAutoreleasePool стал @autoreleasepool { }, retain стал strong. Появился unsafe_unretained

`strong` - «Удерживает объект», увеличивая счетчик ссылок на 1

retain - Тоже самое, что и strong. В проекте с ARC ведет себя также как и strong

`copy` - Копирует объект и «удерживает» копию, увеличивая счетчик ссылок на 1

`assign` - «Не удерживает объект». Счетчик ссылок остается неизменным. Указатель не является безопасным 

`unsafe_unretained` - «Не удерживает объект». Счетчик ссылок остается неизменным. Указатель не является безопасным

`weak` - «Не удерживает объект». Счетчик ссылок остается неизменным. Указатель будет указывать на nil (0x0), если объект деаллоцирован

`Небезопасный указатель` * - если объект деаллоцирован, то указатель на данный участок памяти остается, что при обращении может вызвать неотложное завершение программы.

------



**Q:** Объясните Method Dispatch

**A:** Каким образом могут вызываться методы?

`Direct`, `Witness Table`, `Virtual Table`, `Message Dispatch`

`Direct dispatch` – Быстрота, оптимизации компилятора, отсутствие полиморфизма и наследования

`Virtual and Witness table` – Массив указателей методов у каждого класса. Каждый дочерний класс содержит свою копию таблицы. Новый указатель для override методов. Методы добавляются в конец таблицы. Полиморфизм и наследование

`Message dispatch` – Методы хранятся в структурах по указателю isa KVO. Message Forwarding. Swizzling. Полиморфизм и наследование. Не очень быстрый, хотя и имеется кэширование

|                   | Init declaration | Extension |
| ----------------- | ---------------- | --------- |
| value type        | static           | static    |
| protocol          | table            | static    |
| class             | table            | static    |
| NSObject subclass | table            | message   |

|         |                               |
| ------- | ----------------------------- |
| final   | static                        |
| dynamic | message                       |
| @objc   | Modify Objective-C Visibility |

------



**Q:** Что такое UIApplication и UIWindow?

**A:** `UIApplication` – Сердце вашего приложения. Обрабатывает нажатия пользователей ( начало Responder Chain ). Управление локальными нотификациями ( Local Notifications ). У него есть delegate, которому сообщаются методы жизненного цикла и другие. Регистрация на Remote Notifications ( Удаленные пуш-уведомления )

`UIWindow` – Является фоном UI вашего приложения. Передает пользовательские нажатия представлениям. Используется в роли main Window, для отображения контента всего приложения. Для отображения какого-то дополнительного контента. Только 1 Window в приложении может быть ключевым ( keyWindow )
Он содержит видимый контент вашего приложения
Он играет ключевую роль в доставке сенсорных событий вашим представлениям и другим объектам приложения
Он работает с контроллерами представления вашего приложения для обработки изменений ориентации

------

**Q:** Базовые примитивы синхронизации потоков

**A:** 

- мьютекс
- семафор
- барьер
- условная переменная 
- спинлок

------



**Q:** UIGestureRecognizer

**A:** Логика по работе с объектами типа UITouch/ UIPress. Может любую view «научить» распознавать жесты. Добавляется на конкретную view
Типы – дискретные и непрерывные
Виды – UITapGestureRecognizer, UIPinchGestureRecognizer, UIRotationGestureRecognizer, UISwipeGestureRecognizer, UIPanGestureRecognizer, UIScreenEdgePanGestureRercognizer, UILongPressGestureRecognizer
Цикл:
Possible - готов к работе
Began - начался распознаваемый жест 
Changed - изменение состояния 
Recognized (Ended) - жест закончился 
Cancelled - отменен
Failed - жест не был распознан

------



**Q:** Назовите основные отличия синглтона от статического класса, и когда следует использовать один, а когда другой?

**A:** `Использование синглотона оправдано, когда:`

- Необходимо наследование классов или интерфейсов или делегаровать конструирование объектов фабрике
- Необходимо использование экземпляров класса
- Необходимо контролировать время жизни объекта (хоть это и очень редкая задача для синглтона)
- Необходимо сериализовать объект (такая задача гипотетически возможна, но трудно представить себе сценарии использования)

`Использование статических классов целесообразно тогда,`

- когда у вас нет необходимости реализовывать ни один из сценариев перечисленных для синглтона.
- Основное назначение статических классов все-таки в группировке логически схожих методов, констант, полей и свойств. Например: `System.Math, System.BitConverter, System.Buffer, System.Convert` и т.д.

`Singleton vs Static class`

- Количество точек доступа
  - 1. Одна (и только одна) точка доступа — статическое поле Instance
  - 1. N (зависит от количества публичных членов класса и методов)
- Наследование классов
  - 1. Возможно, но не всегда (об этом — ниже)
  - 1. Невозможно — статические классы не могут быть экземплярными, поскольку нельзя создавать экземпляры объекты статических классов
- Наследование интерфейсов
  - 1. Возможно, безо всяких ограничений
  - 1. Невозможно по той же причине, по которой невозможно наследование классов
- Возможность передачи в качестве параметров
  - 1. Возможно, поскольку Singleton предоставляет реальный объект
  - 1. Отсутствует
- Контроль времени жизни объекта
  - 1. Возможно — например, отложенная инициализация (или создание по требованию)
  - 1. Невозможно по той же причине, по которой невозможно наследование классов
- Использование абстрактной фабрики для создания экземпляра класса
  - 1. Возможно
  - 1. Невозможно по причине осутствия самой возможности создания экземпляра

`Сериализация`

- 1. Возможно
- 1. Неприменима по причине отсутствия экземпляра

`Статический класс`

Статический класс - это обычный контейнер для наборов методов, работающий на входных параметрах и не должен возвращать или устанавливать каких-либо внутренных полей экземпляра.

- Содержит только статические методы.
- Нельзя создавать его экземпляры.
- Не может содержать конструкторов/деструкторов экземпляра.

`Синглтон`

Один из порождающих паттернов. Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

- Синглтоны бывают потокобезопасные или нет.
- C простой или отложенной инициализацией.

------



**Q:** Как работает асинхронность в iOS?

**A:** Асинхронный код убирает блокирующую операцию из основного потока программы, так что она продолжает выполняться, но где-то в другом месте, а обработчик может идти дальше. Проще говоря, главный «процесс» ставит задачу и передает ее другому независимому «процессу».

------



**Q:** Объектно-Ориентированное Программирование

**A:** 

`Инкапсуляция`

Cвойство языка программирования, позволяющее пользователю не задумываться о сложности реализации используемого программного компонента (что у него внутри?), а взаимодействовать с ним посредством предоставляемого интерфейса (публичных методов и членов), а также объединить и защитить жизненно важные для компонента данные. При этом пользователю предоставляется только спецификация (интерфейс) объекта.

Сокрытие методов и переменных от других методов или переменных или других частей программы.
Сокрытие реализации целесообразно применять в следующих целях:

1. При необходимости максимальной локализации предстоящих изменений, когда изменяется только работа объекта, а не программы;
2. При необходимости предсказания предстоящих изменений и их последствий;
3. При необходимости очистки глобальной области видимости;

`Нарушение инкапсуляции` - это раскрытие внутренней реализации класса, а также использование полей класса в обход диспетчеризации (геттеры, сеттеры).
Нарушение инкапсуляции - это утечка внутренней логики работы класса. Пример: прямое обращение к внутренним переменным класса

Пользователь может взаимодействовать с объектом только через этот интерфейс. 



`Наследование`

Процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Польза наследования в том, что оно дополняет идею абстракции. Абстракция позволяет представить объекты с разным уровнем детальности. Наследование упрощает программирование, позволяя создать универсальные методы для выполнения всего, что основано на общих свойствах, и затем написать специфические методы для выполнения специфических операций над конкретными типами данных.



`Полиморфизм`

Возможность объектов с одинаковой спецификацией иметь различную реализацию (использование одного имени для решения двух или более схожих, но технически разных задач).
Целью полиморфизма является использование одного имени для задания общих для класса действий. Выполнение каждого конкретного действия будет определяться типом данных. Концепцией полиморфизма является идея «один интерфейс, множество методов». Это означает, что можно создать общий интерфейс для группы близких по смыслу действий. Преимуществом полиморфизма является то, что он помогает понизить сложность разработки, разрешая использование того же интерфейса для задания единого класса действий. Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор.

Язык программирования поддерживает полиморфизм, если классы с одинаковой спецификацией могут иметь различную реализацию — например, реализация класса может быть изменена в процессе наследования.
Кратко смысл полиморфизма можно выразить фразой: `«Один интерфейс, множество реализаций».`
Единый интерфейс реализуется с помощью `протоколов`.

`Полиморфные объекты` создаются с помощью обобщенного `типа id` и могут содержать разные типы в разный момент времени.

`Анонимные объекты` создаются с помощью протокола и типа id (Это объекты без информации о типе и внутренней структуре объекта)



`Конструктор`

Специальный блок инструкций, вызываемый при создании объекта. Выполняется по умолчанию, не требует дополнительного вызова. Используется для инициализации членов класса, расчёта значений, необходимых для работы созданного объекта и тому подобное.



`Назначенный инициализатор`

Главный инициализатор (конструктор), все остальные методы создающие класс вызывают этот метод.



`Деструктор`

Вызывается при уничтожении объекта. Он обычно используется для освобождения памяти.



`Виртуальный метод`

Метод, который может быть переопределён в классах-наследниках так, что конкретная реализация метода для вызова будет определяться во время исполнения.

Разработчику необязательно знать точный тип объекта для работы с ним через виртуальные методы: достаточно лишь знать, что объект принадлежит классу или наследнику класса, в котором метод объявлен.

Является одним из приёмов реализации полиморфизма. Виртуальные методы позволяют создавать общий код, который может работать как с объектами базового класса, так и с объектами любого его класса-наследника. При этом базовый класс определяет способ работы с объектами и любые его наследники могут предоставлять конкретную реализацию этого способа.

------



**Q:** KISS

**A:** 

- Разбивайте задачи на подзадачи которые не должны по вашему мнению длиться более 4-12 часов написания кода;
- Разбивайте задачу на множество более маленьких задач, каждая задача должна решаться одним или парой классов;
- Сохраняйте ваши методы маленькими. Каждый метод должен состоять не более чем из 30-40 строк. Каждый метод должен решать одну маленькую задачу, а не множество случаев. Если в вашем методе множество условий, разбейте его на несколько. Это повысит читаемость, позволит легче поддерживать код и быстрее находить ошибки в нём. Вы полюбите улучшать код;
- Сохраняйте ваши классы маленькими. Здесь применяется та же техника что и с методами.
- Придумайте решение задачи сначала, потом напишите код. Никогда не поступайте иначе. Многие разработчики придумывают решение задачи во время написания кода и в этом нет ничего плохого. Вы можете делать так и при этом придерживаться выше обозначенного правила. Если вы можете в уме разбивать задачу на более мелкие части, когда вы пишете код, делайте это любыми способами. И не бойтесь переписывать код ещё и ещё и ещё… В счёт не идёт число строк, до тех пор пока вы считаете что можно ещё меньше/ещё лучше;
- Не бойтесь избавляться от кода. Изменение старого кода и написание нового решения два очень важных момента. Если вы столкнулись с новыми требованиями, или не были оповещены о них ранее, тогда порой лучше придумать новое более изящное решение решающее и старые и новые задачи;

------



**Q:** DRY

**A:** Don’t repeat yourself (не повторяй самого себя).
Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы.

------



**Q:** YAGNI

**A:** You aren't gonna need it — процесс и принцип проектирования [ПО](https://ru.wikipedia.org/wiki/Программное_обеспечение), при котором в качестве основной цели и/или ценности декларируется отказ от избыточной функциональности, — то есть отказ добавления функциональности, в которой нет непосредственной надобности.
Все что не предусмотрено техническим заданием проекта, не должно быть в нем.

------



**Q:** RootViewController

**A:** Корневой контроллер обеспечивает представление содержимого window.
Назначение контроллера этому свойству (программно или с помощью Interface Builder) устанавливает view контроллера в качестве view содержимого window. Новое view содержимого настроено на отслеживание размера window, изменяющегося при изменении размера window.
Если window имеет существующую иерархию views, старые views удаляются до установки новых.
Значением по умолчанию этого свойства является null.

------
